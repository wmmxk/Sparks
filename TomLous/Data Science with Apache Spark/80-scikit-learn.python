{"version":"NotebookV1","origId":503877321549371,"name":"80-scikit-learn","language":"python","commands":[{"version":"CommandV1","origId":503877321549373,"guid":"c0b3d795-55b6-4e70-985e-df40e3cdef68","subtype":"command","commandType":"auto","position":2.0,"command":"%md\n# External modeling libraries\n---\nHow can we leverage our existing experience with modeling libraries like [scikit-learn](http://scikit-learn.org/stable/index.html)?  We'll explore three approaches that make use of existing libraries, but still benefit from the parallelism provided by Spark.\n\nThese approaches are:\n * Grid Search\n * Cross Validation\n * Sampling\n \nWe'll start by using scikit-learn on the driver and then we'll demonstrate the parallel techniques.","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"69698ae5-a6f3-4f9c-b784-2cc07df46a1d"},{"version":"CommandV1","origId":503877321549374,"guid":"28e2822d-1e59-4ab4-a793-a21517b651be","subtype":"command","commandType":"auto","position":3.0,"command":"%md\n## Part 1: Use scikit-learn locally","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b7f5affc-2d97-48fa-9a10-0dbb35ea5e06"},{"version":"CommandV1","origId":503877321549375,"guid":"631d5a2f-48ed-4a32-8ac4-fa874819e7f9","subtype":"command","commandType":"auto","position":4.0,"command":"%md\nLoad the data from `sklearn.datasets`, and create test and train sets.","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"874ac554-3a98-406c-b5e2-baf8665c7669"},{"version":"CommandV1","origId":503877321549376,"guid":"36a148bf-040d-4e4f-a1ab-1d806b9e577d","subtype":"command","commandType":"auto","position":5.0,"command":"import numpy as np\nfrom sklearn import datasets","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"7a67951c-1f84-4964-9117-e045c106f135"},{"version":"CommandV1","origId":503877321549377,"guid":"5bcf20d0-fa09-48aa-b0e5-100450257d49","subtype":"command","commandType":"auto","position":6.0,"command":"# Load the data\niris = datasets.load_iris()\n\n# Generate test and train sets\nsize = len(iris.target)\nindices = np.random.permutation(size)\n\ncutoff = int(size * .30)\n\ntestX = iris.data[indices[0:cutoff],:]\ntrainX = iris.data[indices[cutoff:],:]\ntestY = iris.target[indices[0:cutoff]]\ntrainY = iris.target[indices[cutoff:]]","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5c41a06f-89b9-4076-a423-1fd430a69e81"},{"version":"CommandV1","origId":503877321549378,"guid":"88f6f9ea-bc6a-43a9-af04-c8e5768caa10","subtype":"command","commandType":"auto","position":7.0,"command":"type(iris.data)","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"2eca7a4e-f1fd-483c-93cd-a63f4af25a5a"},{"version":"CommandV1","origId":503877321549379,"guid":"8f2b20cc-5828-43c1-bb70-fbc10a4fdc86","subtype":"command","commandType":"auto","position":8.0,"command":"iris.data[100]","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"cc742800-e84f-4cdc-b5f5-f3eb872c2b52"},{"version":"CommandV1","origId":503877321549380,"guid":"29e1c906-4a2b-4eed-ae76-7e4ac9715c41","subtype":"command","commandType":"auto","position":9.0,"command":"iris.target[100]","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"9012462b-dab4-435e-88a3-4068c520d72e"},{"version":"CommandV1","origId":503877321549381,"guid":"95e52ce5-3d24-46db-b1ac-8cdb1c70e9e3","subtype":"command","commandType":"auto","position":10.0,"command":"%md\nBuild a nearest neighbors classifier using [sklearn.neighbors.KNeighborsClassifier](http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html).","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"506c146d-ceba-46d7-beb0-c171740eb32e"},{"version":"CommandV1","origId":503877321549382,"guid":"124e98b3-3ccc-4938-aba0-98eb4b33d664","subtype":"command","commandType":"auto","position":11.0,"command":"from sklearn.neighbors import KNeighborsClassifier\n\n# Create a KNeighborsClassifier using the default settings\nknn = KNeighborsClassifier()\nknn.fit(trainX, trainY)\n\npredictions = knn.predict(testX)\n\n# Print out the accuracy of the classifier on the test set\nprint sum(predictions == testY) / float(len(testY))","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"d282e4ad-d6dd-44af-bd84-e2ab921dc4b2"},{"version":"CommandV1","origId":503877321549383,"guid":"937953be-37a1-4d25-8cb2-a600dc9f0082","subtype":"command","commandType":"auto","position":12.0,"command":"%md\n## Part 2: Grid Search","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5c1fd982-8bf3-4725-bd1b-8d2e7a9438a0"},{"version":"CommandV1","origId":503877321549384,"guid":"944b1827-eb67-4858-aa33-32e86b8cc43f","subtype":"command","commandType":"auto","position":13.0,"command":"%md\nDefine a function `runNearestNeighbors` that takes in a parameter `k` and returns a tuple of (`k`, accuracy).  Note that we'll load the data from `sklearn.datasets`, and we'll create train and test splits using [sklearn.cross_validation.train_test_split](http://scikit-learn.org/stable/modules/generated/sklearn.cross_validation.train_test_split.html).","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"cb545be2-a550-424e-8667-8b78221af209"},{"version":"CommandV1","origId":503877321549385,"guid":"690daaec-76d6-42b6-9758-345526773d61","subtype":"command","commandType":"auto","position":14.0,"command":"from sklearn.cross_validation import train_test_split\n\ndef runNearestNeighbors(k):\n    # Load dataset from sklearn.datasets\n    irisData = datasets.load_iris()\n    \n    # Split into train and test using sklearn.cross_validation.train_test_split\n    yTrain, yTest, XTrain, XTest = train_test_split(irisData.target, \n                                                    irisData.data)\n    \n    # Build the model\n    knn = KNeighborsClassifier(n_neighbors=k)\n    knn.fit(XTrain, yTrain)\n    \n    # Calculate predictions and accuracy\n    predictions = knn.predict(XTest)\n    accuracy = (predictions == yTest).sum() / float(len(yTest))\n    \n    return (k, accuracy)   ","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"0f1d0990-dad4-4b09-9312-1da525bd7b91"},{"version":"CommandV1","origId":503877321549386,"guid":"2fd1ca6f-3501-4662-85d1-51816e281fb4","subtype":"command","commandType":"auto","position":15.0,"command":"%md\nNow we'll run a grid search for `k` from 1 to 10.","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ccc425f6-a414-477c-a06b-167108cef2ba"},{"version":"CommandV1","origId":503877321549387,"guid":"de122c68-1e4c-4188-a421-3fb310a1a362","subtype":"command","commandType":"auto","position":16.0,"command":"k = sc.parallelize(xrange(1, 11))\nresults = k.map(runNearestNeighbors)\nprint '\\n'.join(map(str, results.collect()))","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b60f575b-0093-4c90-96cc-cab4425f7ce4"},{"version":"CommandV1","origId":503877321549388,"guid":"ae45d3aa-2820-43ec-a283-e6e9a387565b","subtype":"command","commandType":"auto","position":17.0,"command":"%md\nLet's transfer the data using a Broadcast instead of loading it at each executor.  You can create a [Broadcast](http://spark.apache.org/docs/latest/api/python/pyspark.html#pyspark.Broadcast) variable using [sc.broadcast()](http://spark.apache.org/docs/latest/api/python/pyspark.html#pyspark.SparkContext.broadcast).","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"77504bd4-4f49-40bb-8c3e-c4736bc8bcf1"},{"version":"CommandV1","origId":503877321549389,"guid":"ad946eff-647a-41b9-b789-8de65a94449b","subtype":"command","commandType":"auto","position":18.0,"command":"# Create the Broadcast variable\nirisBroadcast = sc.broadcast(iris)\n\ndef runNearestNeighborsBroadcast(k):\n    # Using the data in the irisBroadcast variable split into train and test using\n    # sklearn.cross_validation.train_test_split\n    yTrain, yTest, XTrain, XTest = train_test_split(irisBroadcast.value.target,\n                                                    irisBroadcast.value.data)\n    \n    # Build the model\n    knn = KNeighborsClassifier(n_neighbors=k)\n    knn.fit(XTrain, yTrain)\n    \n    # Calculate predictions and accuracy\n    predictions = knn.predict(XTest)\n    accuracy = (predictions == yTest).sum() / float(len(yTest))\n    \n    return (k, accuracy)   \n  \n# Rerun grid search\nk = sc.parallelize(xrange(1, 11))\nresults = k.map(runNearestNeighborsBroadcast)\nprint '\\n'.join(map(str, results.collect()))","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"03705959-0b44-40f3-9d65-0c0dd8926fd1"},{"version":"CommandV1","origId":503877321549390,"guid":"bbe78958-a4f8-485b-84d5-c9bee2ff2c5e","subtype":"command","commandType":"auto","position":19.0,"command":"%md\n### Part 3: Cross Validation","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"1f3dca48-ccae-423b-9c6b-f030504d85d6"},{"version":"CommandV1","origId":503877321549391,"guid":"9927eac5-7dd3-472b-bf1b-62484b13fcb5","subtype":"command","commandType":"auto","position":20.0,"command":"%md\nNow we'll use [sklearn.cross_validation.KFold](http://scikit-learn.org/stable/modules/generated/sklearn.cross_validation.KFold.html) to evaluate our model using 10-fold cross validation.  First, generate the 10 folds using `KFold`.","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"172c8108-b710-409d-8a55-62df1d9126a1"},{"version":"CommandV1","origId":503877321549392,"guid":"11d054f1-af85-4aa4-8a0e-b8da24e2fc12","subtype":"command","commandType":"auto","position":21.0,"command":"from sklearn.cross_validation import KFold\n\n# Create indicies for 10-fold cross validation\nkf = KFold(size, n_folds=10)\n\nprint len(kf)\n\nprint kf.__iter__()\n\ntrain, test = kf.__iter__().next()\n\nprint \"First fold:\"\n\nprint \"Train:\" + str(train)\n\nprint \"Test:\" + str(test)","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5e6d85be-e6a3-4b69-a343-10898f25a5cf"},{"version":"CommandV1","origId":503877321549393,"guid":"62684576-c1ce-40cc-84f3-e6f83f84fd79","subtype":"command","commandType":"auto","position":22.0,"command":"folds = sc.parallelize(kf)\nprint folds.take(1)","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"22f1e474-0329-454f-ae34-55ce9c704d9d"},{"version":"CommandV1","origId":503877321549394,"guid":"41942f93-6da5-4d23-8026-b8e294913374","subtype":"command","commandType":"auto","position":23.0,"command":"%md\nCreate a function that runs nearest neighbors based on the fold information passed in.  Note that we'll have the function return an [np.array](http://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html) which provides us with additional functionality that we'll take advantage of in a couple steps.","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"fba3f35c-b6b4-4be0-bcd5-e49eda1af8dc"},{"version":"CommandV1","origId":503877321549395,"guid":"35553ff7-c032-4bb2-ac2e-aad2cbcd62ea","subtype":"command","commandType":"auto","position":24.0,"command":"import numpy as np\n\ndef runNearestNeighborsWithFolds((trainIndex, testIndex)):\n    # Assign training and test sets from irisBroadcast using trainIndex and testIndex\n    XTrain = irisBroadcast.value.data[trainIndex]\n    yTrain = irisBroadcast.value.target[trainIndex]\n    XTest = irisBroadcast.value.data[testIndex]\n    yTest = irisBroadcast.value.target[testIndex]\n    \n   # Build the model\n    knn = KNeighborsClassifier(n_neighbors=5)\n    knn.fit(XTrain, yTrain)\n    \n    # Calculate predictions\n    predictions = knn.predict(XTest)\n    \n    # Compute the number of correct predictions and total predictions\n    correct = (predictions == yTest).sum() \n    total = len(testIndex)\n    \n    # Return an np.array of the number of correct predictions and total predictions\n    return np.array([correct, total])","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"7f00e163-1583-42b9-adc9-dd01da593fc8"},{"version":"CommandV1","origId":503877321549396,"guid":"f24ac2fd-0702-4294-b108-e15539b6571f","subtype":"command","commandType":"auto","position":25.0,"command":"%md\nComputer nearest neighbors using each fold.","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ddbfab08-2062-470a-ba23-77bf417f211e"},{"version":"CommandV1","origId":503877321549397,"guid":"3854f626-608b-4349-9824-5836c0ebafb3","subtype":"command","commandType":"auto","position":26.0,"command":"# Run nearest neighbors on each of the folds\nfoldResults = folds.map(runNearestNeighborsWithFolds)\nprint 'correct / total\\n' + '\\n'.join(map(str, foldResults.collect()))","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"efa4168b-cf22-426a-aacd-71ab3824a719"},{"version":"CommandV1","origId":503877321549398,"guid":"a4192853-b10f-4c63-b495-b30ba19b3fa3","subtype":"command","commandType":"auto","position":27.0,"command":"%md\nNow aggregate the results from the folds to see overall accuracy","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8afa44eb-c0af-4a8a-b31e-353c6a40f669"},{"version":"CommandV1","origId":503877321549399,"guid":"aacf95e7-1d95-4495-9d8f-172fe9d2c766","subtype":"command","commandType":"auto","position":28.0,"command":"# Note that using .sum() on an RDD of numpy arrays sums by columns \ncorrect, total = foldResults.sum()\nprint correct / float(total)","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"81dd52b9-7daa-4823-bc2b-16f5131c9a76"},{"version":"CommandV1","origId":503877321549400,"guid":"8d510cde-7a1a-4050-900e-bb7918a32843","subtype":"command","commandType":"auto","position":29.0,"command":"%md\n### Part 4: Sampling","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b59ad629-7a15-4918-94af-2be32811ae25"},{"version":"CommandV1","origId":503877321549401,"guid":"0434f135-62ab-404a-934b-45aa1b441293","subtype":"command","commandType":"auto","position":30.0,"command":"%md\nWe might have a dataset that is too large where we can't use our external modeling library on the full data set.  In this case we might want to build several models on samples of the dataset.  We could either build the same model, using different parameters, or try completely different techniques to see what works best.","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"aad960f5-53e0-4c43-b545-1620364d8014"},{"version":"CommandV1","origId":503877321549402,"guid":"f7aa8907-f289-466b-927c-ec06b7d521c7","subtype":"command","commandType":"auto","position":31.0,"command":"%md\nFirst we'll parallelize the iris dataset and distributed it across our cluster.  ","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"91d89280-c731-46aa-826c-a005495f06bb"},{"version":"CommandV1","origId":503877321549403,"guid":"3397568b-d58a-4415-81b6-5ed44db558eb","subtype":"command","commandType":"auto","position":32.0,"command":"# Split the iris dataset into 8 partitions\nirisData = sc.parallelize(zip(iris.target, iris.data), 8)\nprint irisData.take(2), '\\n'\n\n# View the number of elements found in each of the eight partitions\nprint (irisData\n       .mapPartitions(lambda x: [len(list(x))])\n       .collect())\n\n# View the target (y) stored by partition\nprint '\\n', irisData.keys().glom().collect()","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"78b0e3b3-5866-478b-aee6-9fe2ad28adf7"},{"version":"CommandV1","origId":503877321549404,"guid":"a0643140-104e-4006-a98c-76c9c5d32476","subtype":"command","commandType":"auto","position":33.0,"command":"%md\nSince each of the partitions represents a dataset that we'll be using to run our local model, we have a problem.  The data is ordered, so our partitions are mostly homogenous with regard to our target variable.\n\nWe'll repartition the data using `partitionBy` so that the data is randomly ordered across partitions.","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ff579a5f-cac7-46d0-9382-eefa2c2a1afd"},{"version":"CommandV1","origId":503877321549405,"guid":"ddc40d8e-7043-4eea-9c48-79234957a667","subtype":"command","commandType":"auto","position":34.0,"command":"# Randomly reorder the data across partitions\nrandomOrderData = (irisData\n                   .map(lambda x: (np.random.randint(5), x))\n                   .partitionBy(5)\n                   .values())\n\n# Show the new groupings of target variables\nprint randomOrderData.keys().glom().collect()","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"49422615-5ff3-450d-9e90-e64dec793ac1"},{"version":"CommandV1","origId":503877321549406,"guid":"a529d444-28ca-4092-822d-24e4a4c5ecbb","subtype":"command","commandType":"auto","position":35.0,"command":"%md\nFinally, we'll build a function that takes in the target and data from the `randomOrderData` RDD and returns the number of correct and total predictions (with regard to a test set).","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f1181dd0-6e46-4cbb-adc5-30c824a95287"},{"version":"CommandV1","origId":503877321549407,"guid":"5c124c43-3145-44fc-a6ae-04f20c505c2e","subtype":"command","commandType":"auto","position":36.0,"command":"# Recall what randomOrderData contains\nprint randomOrderData.take(3)","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"78312680-06d2-4a44-a61b-caddb33da0c0"},{"version":"CommandV1","origId":503877321549408,"guid":"ffe4c020-0b4b-4512-ad8f-1c04df28a166","subtype":"command","commandType":"auto","position":37.0,"command":"def runNearestNeighborsPartition(labelAndFeatures):\n    y, X = zip(*labelAndFeatures)\n    yTrain, yTest, XTrain, XTest = train_test_split(y, X)\n    \n    knn = KNeighborsClassifier()\n    knn.fit(XTrain, yTrain)\n    \n    predictions = knn.predict(XTest)\n    correct = (predictions == yTest).sum() \n    total = len(yTest)\n    return [np.array([correct, total])]\n\nsampleResults = randomOrderData.mapPartitions(runNearestNeighborsPartition)\n\nprint 'correct / total\\n' + '\\n'.join(map(str, sampleResults.collect()))","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8b4b33b9-0537-4df2-bb92-021b4af0b063"},{"version":"CommandV1","origId":503877321549409,"guid":"b49634a2-c4a9-4c86-be5e-f7295f5ceb20","subtype":"command","commandType":"auto","position":38.0,"command":"","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"2280aa09-5193-48dc-901f-709464ce3af0"}],"dashboards":[],"guid":"d6b7161f-339c-4cdb-ab63-dcfb3bbe5738","globalVars":{},"iPythonMetadata":null,"inputWidgets":{}}