{"version":"NotebookV1","origId":503877321549014,"name":"50-Logistic","language":"scala","commands":[{"version":"CommandV1","origId":503877321549016,"guid":"3a83ef73-0fee-492f-a672-1e2894c5959c","subtype":"command","commandType":"auto","position":1.0,"command":"%md ####In this notebook, we'll use the knowledge we've already gained, and add some new tips. \n\nWe'll use Spark for:\n\n* Logistic Regression\n* Sentiment Analysis\n* Natural Language Processing (NLP)\n* ROC Visualizations","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"43e6eca2-0ee1-47fc-a253-e14ee3223a48"},{"version":"CommandV1","origId":503877321549017,"guid":"a86df0ff-0345-4257-83c5-cef055ba512b","subtype":"command","commandType":"auto","position":2.0,"command":"%md Databricks datasets includes a set of about 20,000 Amazon reviews including the English language text and the \"star\" rating associated with the review (1-star, 4-star, etc.)\n\nWe'll use this data to explore the hypothesis that the diction used in a review correlates to sentiment (positive or negative). This hypothesis is possible to test because we have __labeled data__ -- i.e., we have the review scores, so we can train and test.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"26edb57b-660e-4b75-881d-6c0bf0e31a24"},{"version":"CommandV1","origId":503877321549018,"guid":"69cfe49b-a612-4989-8dd6-4be7d77216f8","subtype":"command","commandType":"auto","position":3.0,"command":"val data = spark.read.parquet(\"/databricks-datasets/amazon/data20K\")\ndata.createOrReplaceTempView(\"reviews\")\ndisplay(data)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f973849d-7df0-4726-91ae-8ac572299cf1"},{"version":"CommandV1","origId":503877321549019,"guid":"f857b2cd-cce1-4a32-b47a-4685690367f0","subtype":"command","commandType":"auto","position":4.0,"command":"%md What does the distribution of scores look like?","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"3767eabf-1060-4ae8-882f-ad40fdafab13"},{"version":"CommandV1","origId":503877321549020,"guid":"3a409432-ecfa-4178-92b8-e8e321c4dabb","subtype":"command","commandType":"auto","position":5.0,"command":"%sql SELECT count(1), rating FROM reviews GROUP BY rating ORDER BY rating","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"26687ea5-5918-4da4-8d9c-e14ef03d5d82"},{"version":"CommandV1","origId":503877321549021,"guid":"de7d0f81-ad94-4246-a2e6-cf65d145c885","subtype":"command","commandType":"auto","position":6.0,"command":"%md The overwhelming majority of the reviews are good (4-5 stars) -- we'll have to keep an eye on the possible effects of this on our results. In practice, solutions to this might include stratified sampling, or oversampling of the negative reviews.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"0c7c48c6-dd98-442c-bef9-4f1ed16fa7f4"},{"version":"CommandV1","origId":503877321549022,"guid":"d386c379-bacf-48f3-9eb6-030b7ad0d138","subtype":"command","commandType":"auto","position":7.0,"command":"%md __What does the distribution look like for reviews including the word \"great\"?__","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f879a9da-5a1c-463f-a583-c331e77f1ac5"},{"version":"CommandV1","origId":503877321549023,"guid":"3bbd29ee-6ac8-46eb-bbeb-bd4e376986b7","subtype":"command","commandType":"auto","position":8.0,"command":"%sql SELECT count(1), rating FROM reviews WHERE review LIKE '%great%' GROUP BY rating ORDER BY rating","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ecb40566-e1a5-45a5-9029-5b4f6d419b2b"},{"version":"CommandV1","origId":503877321549024,"guid":"9d2b5ca2-c60d-4706-bc6d-cbdaba085241","subtype":"command","commandType":"auto","position":9.0,"command":"%md No too surprising -- but remember that uneven distribution of star ratings! Other things being equal, we should expect a distribution with a shape something like this -- though even for a neutral word like \"the\" ... the main information here is at the lower end, where a smaller proportion of 1- and 2-star reviews appear with \"great\"\n\nHow about the word \"poor\"?","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c34209d0-a8a4-4c5a-a97e-86f7ea903df7"},{"version":"CommandV1","origId":503877321549025,"guid":"8332cb99-d5fe-4950-8f2a-b93ffb3dff52","subtype":"command","commandType":"auto","position":10.0,"command":"%sql SELECT count(1), rating FROM reviews WHERE review LIKE '%poor%' GROUP BY rating ORDER BY rating","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"d4ac62f3-2d16-4cb2-9185-445bbaa36b94"},{"version":"CommandV1","origId":503877321549026,"guid":"5e781603-66fe-408a-b3f1-99aed2bd98dc","subtype":"command","commandType":"auto","position":11.0,"command":"%md That is both not surprising and fairly informative: the disparity in star distribution makes this result even more significant","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"7efea9df-bc85-4293-9cce-24bde211522d"},{"version":"CommandV1","origId":503877321549027,"guid":"9e1f8f9d-fdc1-4325-9803-9d1943ea305c","subtype":"command","commandType":"auto","position":12.0,"command":"%md Ok, so what is the strategy for training a machine learning model?\n\nSince we're predicting two sentiment categories, \"positive\" and \"negative\", this is a 2-class classification problem.\n\nTo explore the hypothesis idea that may be a linear decision boundary in the feature space of \"diction\" there are some choices to make:\n\n* What model shall we try? Logistic regression, linear SVM, MARS, linear discriminant analysis, something else...?\n* How shall we convert the review contents (a text string) into a vector in a feature space?\n\nIn this notebook, we'll try a logistic regression model, and we'll make the following assumptions about featurization. Naturally, all of these assumptions are subject to question.\n\n* \"Bag-of-words\" model -- i.e., we will retain some form of word counts but no higher-order data such as n-grams, part-of-speech, etc.\n* Frequent words are more interesting than infrequent words. Why? our hypothesis is that there is a smallish number of sentiment-carrying words in the corpus voabulary, whereas there is a large number of \"technical\" product-related words which are less informative.\n  * Given this hypothesis, we'll use a helper that keeps the most frequent words rather than most of the words (CountVectorizer vs. HashingTF)\n* We can split up our text on sequences of 1 or more \"non-word\" chars and we'll be ok (this is not a given for all material)\n* The most common English words (\"of\" \"the\" \"and\" \"firs\" etc.) carry little information for us, so we want to filter them out\n\n\nGiven all that, how do we prep the dataset with Spark? \n\nLike the \"VectorAssembler\" we saw earlier, Spark proviedes \"feature helper\" classes that will do this work for us.\n\nWe'll use:\n* RegexTokenizer\n* StopWordsRemover\n* CountVectorizer\n\nLet's talk about what they do and figure out if they are \"Transformers\" or \"Estimators\" (and why)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"0806c403-b632-4809-a08b-7a5515efa53d"},{"version":"CommandV1","origId":503877321549028,"guid":"3688c2ab-e05f-42fd-b844-85e92428381d","subtype":"command","commandType":"auto","position":13.0,"command":"import org.apache.spark.ml._\nimport org.apache.spark.ml.feature._\n\nval tokenizer = new RegexTokenizer()\n  .setInputCol(\"review\")\n  .setOutputCol(\"tokens\")\n  .setPattern(\"\\\\W+\")\n\nval remover = new StopWordsRemover()\n  .setInputCol(\"tokens\")\n  .setOutputCol(\"stopWordFree\")\n\nval counts = new CountVectorizer()\n  .setInputCol(\"stopWordFree\")\n  .setOutputCol(\"features\")\n  .setVocabSize(1000)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"e450d1ed-56df-4e1a-b49f-f2c500d022c7"},{"version":"CommandV1","origId":503877321549029,"guid":"03086f75-5507-4812-9410-8d8789871292","subtype":"command","commandType":"auto","position":14.0,"command":"%md Where do the stop words come actually come from? Spark includes a small English list as a default, which we're implicitly using here. For many real-world problems, you'll want to supply your own set of stop words which are customized for the business domain and tweaked to tune the model for performance","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b48c36e6-6150-4b5a-b102-65b212cb5190"},{"version":"CommandV1","origId":503877321549030,"guid":"fd1c7cbc-8c05-432a-a339-4c15d51f4dd0","subtype":"command","commandType":"auto","position":15.0,"command":"remover.getStopWords","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"a4a30675-5ceb-4623-a8d0-5237a7d6678b"},{"version":"CommandV1","origId":503877321549031,"guid":"0b86fce8-1125-4060-95f2-33858e48ec49","subtype":"command","commandType":"auto","position":16.0,"command":"%md Before moving on, you can insert a cell in the notebook and try out the feature helpers above, manually. To do so, make sure the column names line up with the DataFrame you're using, and call `transform` to run a Transformer. To try an Estimator, call `fit` on the datato calculate and emit the Estimator's `Model` and then call the model's `transform` method on the DataFrame.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5fc9166e-a59c-4844-b8a7-386373fc7cd7"},{"version":"CommandV1","origId":503877321549032,"guid":"9c44dce4-393f-4d13-a4b5-09a6a6bc287c","subtype":"command","commandType":"auto","position":17.0,"command":"// Scratch area to try out the feature processing steps","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"4af45b3f-2666-4e80-8539-010077336c75"},{"version":"CommandV1","origId":503877321549033,"guid":"7d582847-0978-42df-88dc-729382009ca4","subtype":"command","commandType":"auto","position":18.0,"command":"%md __Now let's adjust the label (target) values__\n\nWe want to group the reviews into \"positive\" or \"negative\" sentiment. So all of the star \"levels\" need to be collapsed into one of two groups.\n\nSpark has two helpers we can choose from:\n\n* a more general \"Bucketizer\" that converts a (potentially) continuous feature into a finite set of buckets with cutoff thresholds\n* a specific two-class Binarizer ... effectively the same thing, but for just two buckets: negative infinity up through threshold, and anything over threshold\n\nFor the Amazon reviews, let's call 4-star and 5-star reviews \"positive\" -- so we can use a threshold of 3.5.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"64847b95-8083-4b01-ab30-6f0129716e89"},{"version":"CommandV1","origId":503877321549034,"guid":"633280fc-0b44-477f-92b4-9ba59b6c8bac","subtype":"command","commandType":"auto","position":19.0,"command":"val binarizer = new Binarizer()\n  .setInputCol(\"rating\")\n  .setOutputCol(\"label\")\n  .setThreshold(3.5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"45e3e23a-d2be-4b3d-bf71-c8c2cbb1d2e9"},{"version":"CommandV1","origId":503877321549035,"guid":"fbe4b8c8-6ae5-4b8e-94c2-8f3b3f3e0628","subtype":"command","commandType":"auto","position":20.0,"command":"%md We could just as well use a Bucketizer -- and we would want to do that if we were performing multiclass classification. That code would look like this:\n```\nval splits = Array(0, 3.5, 6)\n\nval bucketizer = new Bucketizer()\n  .setInputCol(\"rating\")\n  .setOutputCol(\"label\")\n  .setSplits(splits)\n```","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"1ce0c1b7-3232-45b0-ab04-d64a3f086c33"},{"version":"CommandV1","origId":503877321549036,"guid":"3a7e63e3-5366-44b9-88b2-469fb4b062e9","subtype":"command","commandType":"auto","position":21.0,"command":"%md We'll split our data into training and test samples:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"0f7dd650-301d-4eb4-92dd-e3b94f8e973e"},{"version":"CommandV1","origId":503877321549037,"guid":"567f20fc-f37c-40a5-bda0-752f811ecf33","subtype":"command","commandType":"auto","position":22.0,"command":"val splits = data.randomSplit(Array(0.8, 0.2), 42)\nval train = splits(0).cache\nval test = splits(1).cache","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"32a52861-9952-4db6-935c-6a230dc2f159"},{"version":"CommandV1","origId":503877321549038,"guid":"69a24ac6-3f38-42d5-8f74-7fdad57918e6","subtype":"command","commandType":"auto","position":23.0,"command":"%md Recall how we used a Pipeline object to encapsulate the processing steps in our earlier example. We'll do the same thing here, but with a few more steps in the pipeline:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"e3f17021-7e1a-4cf2-beed-c5ce2a2d63b1"},{"version":"CommandV1","origId":503877321549039,"guid":"ff8455d9-9826-4d1a-ab88-e6a4d6b50a32","subtype":"command","commandType":"auto","position":24.0,"command":"import org.apache.spark.ml.classification._\nimport org.apache.spark.ml.evaluation._\n\nval lr = new LogisticRegression()\n\nval p = new Pipeline().setStages(Array(tokenizer, remover, counts, binarizer, lr))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"910cd1a3-4751-40db-8925-9804da85e68a"},{"version":"CommandV1","origId":503877321549040,"guid":"575b5f1d-9317-4931-8b45-7b4982914718","subtype":"command","commandType":"auto","position":25.0,"command":"%md Now we'll fit the model, and use that model on our test set to see how we did:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"0b33c712-8c6a-4145-94c9-012f0a530937"},{"version":"CommandV1","origId":503877321549041,"guid":"42887c5a-286f-42a9-a74b-6fd0a591b2b0","subtype":"command","commandType":"auto","position":26.0,"command":"val model = p.fit(train)\nmodel.stages.last.asInstanceOf[LogisticRegressionModel].summary.asInstanceOf[BinaryLogisticRegressionSummary].areaUnderROC","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"260b31b6-805d-48bc-8386-dba0f82aa6db"},{"version":"CommandV1","origId":503877321549042,"guid":"fc5128d2-4e80-4275-909a-fc51c9e32dae","subtype":"command","commandType":"auto","position":27.0,"command":"%md Many Spark models support a \"training summary\" which provides stats on how well the algorithm was able to fit the model to the training set.\n\nThese statistics represent the \"apparent error\" or the training error. We achieved an AUC around 0.91 when training.\n\nBut of course the real measure of the model is how it does with new data, so let's use it on the test data and take a measurement:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"fd8124dd-808e-4e61-9ace-16d6662f9e3b"},{"version":"CommandV1","origId":503877321549043,"guid":"16f4768c-2334-4601-a7e5-f70665f93919","subtype":"command","commandType":"auto","position":28.0,"command":"val result = model.transform(test)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"e5e4dafc-7261-4d68-8c5d-d4e5b5b94626"},{"version":"CommandV1","origId":503877321549044,"guid":"163f36dd-3f79-4396-8dfa-54f20b70fb87","subtype":"command","commandType":"auto","position":29.0,"command":"%md Earlier we saw the RegressionEvaluator. Here, we'll use a BinaryClassificationEvaluator. Same idea, but tailored for these sorts of problems, it exposes statistics like AUC and area under PR (precision-recall) curve.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"dc251536-03ad-4434-9956-38df31383b45"},{"version":"CommandV1","origId":503877321549045,"guid":"db6d6ff4-67b4-43d2-abd6-0ab3ab1a0121","subtype":"command","commandType":"auto","position":30.0,"command":"val evaluator = new BinaryClassificationEvaluator()\nprintln(\"AUC: \" + evaluator.evaluate(result))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"3d1c6933-cd0a-4c7b-abd5-477b14833443"},{"version":"CommandV1","origId":503877321549046,"guid":"13131457-ff5e-4f99-9de0-e27abce28e4c","subtype":"command","commandType":"auto","position":31.0,"command":"%md So, even without any tuning -- just using the defaults in Spark, we're doing ok. We'll take a few minutes for you to try and improve the performance the same way we did with linear regression -- by mutating parameters of the LinearRegression instance or the CountVectorizer instance.\n\nBut, first, let's look at one more thing: Spark can generate a DataFrame that represents the points on the ROC curve, and Databricks can plot it for us.\n\nThe following cell show the same flow, adjusted a tiny bit to match the Databricks notebook `display` call for ROC:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5aff930d-fca0-40dc-bf22-0f358145eed5"},{"version":"CommandV1","origId":503877321549047,"guid":"b066564d-6573-48bc-88ea-cdd6de49c7ca","subtype":"command","commandType":"auto","position":32.0,"command":"val partialPipeline = new Pipeline().setStages(Array(tokenizer, remover, counts, binarizer))\n\nval preppedData = partialPipeline.fit(train).transform(train)\n\nval lrModel = new LogisticRegression().fit(preppedData)\n\ndisplay(lrModel, preppedData, \"ROC\")","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"33e341c8-f7c6-48cd-9396-2e080bbbd6f6"},{"version":"CommandV1","origId":503877321549048,"guid":"36d5542d-7a93-41bd-84d8-17f296a91082","subtype":"command","commandType":"auto","position":33.0,"command":"%md Finally, here's a chance for you to try and beat our initial AUC of around 0.84. The code is mostly set up for you here, and you can try some manual hyperparameter tuning. (We will cover automatic parameter tuning shortly.)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"a7b2ad9a-41b1-44d3-99cd-664af80e89c1"},{"version":"CommandV1","origId":503877321549049,"guid":"49c4519c-dc5b-48d9-9af9-e7aa2677a628","subtype":"command","commandType":"auto","position":34.0,"command":"lr.explainParams","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"3adc6175-3290-4901-b6fa-af395b171b21"},{"version":"CommandV1","origId":503877321549050,"guid":"5a376bc6-644e-4dd3-a1b0-e48a49cb6791","subtype":"command","commandType":"auto","position":35.0,"command":"//These are the defaults or values we've already used ... you can change them\n\nlr.setRegParam(0.0)\nlr.setElasticNetParam(0.0)\ncounts.setVocabSize(1000)\nval model = p.fit(train)\nval result = model.transform(test)\nprintln(\"AUC: \" + new BinaryClassificationEvaluator().evaluate(result))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"3974bac9-e70b-497a-a75a-6dda6164a982"},{"version":"CommandV1","origId":503877321549051,"guid":"662d893e-f58a-45e2-b88f-21aad7380a90","subtype":"command","commandType":"auto","position":36.0,"command":"","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"1bd76ebe-26d4-4209-ae14-f81ecfbb4fbd"}],"dashboards":[],"guid":"7c658498-1010-4deb-9815-411ea52b81e3","globalVars":{},"iPythonMetadata":null,"inputWidgets":{}}