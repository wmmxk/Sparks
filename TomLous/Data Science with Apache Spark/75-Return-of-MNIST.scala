{"version":"NotebookV1","origId":503877321549078,"name":"75-Return-of-MNIST","language":"scala","commands":[{"version":"CommandV1","origId":503877321549080,"guid":"1bde983e-e7f4-4e8e-a2c9-d9f83e85f3fa","subtype":"command","commandType":"auto","position":1.0,"command":"%md # Decision Trees - Tuning with Spark Grid Search\n\n__GOAL: Replace the \"manual\" tuning of the trees in this notebook with grid search, using ParamGridBuilder, CrossValidator, and Evaluator__\n\n__we'll do the first one together, and you can try your hand at the second tuning exersise in the notebook__","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"dea6c8af-54fa-4a7f-af25-87146e4002d3"},{"version":"CommandV1","origId":503877321549081,"guid":"409fd95d-ceea-4c79-8eab-a7965ba82182","subtype":"command","commandType":"auto","position":2.0,"command":"%md We'll get set up as before:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"15762bae-8a82-4d7f-a9f1-f1e61ac766c2"},{"version":"CommandV1","origId":503877321549082,"guid":"76b02c92-eab2-4e99-aad9-e4d581e396ea","subtype":"command","commandType":"auto","position":3.0,"command":"val training = sqlContext.read.format(\"libsvm\").load(\"/databricks-datasets/mnist-digits/data-001/mnist-digits-train.txt\").cache\nval test = sqlContext.read.format(\"libsvm\").load(\"/databricks-datasets/mnist-digits/data-001/mnist-digits-test.txt\").cache","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"9cb37e3a-5799-463f-a1dd-781fa73eb712"},{"version":"CommandV1","origId":503877321549083,"guid":"7322a303-dec3-45a5-9dca-290d2bf6ca97","subtype":"command","commandType":"auto","position":4.0,"command":"// Import the ML algorithms we will use.\nimport org.apache.spark.ml.classification.{DecisionTreeClassifier, DecisionTreeClassificationModel}\nimport org.apache.spark.ml.feature.StringIndexer\nimport org.apache.spark.ml.Pipeline","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"1df5cefc-94f3-4f8c-9ee8-d61bcd364d34"},{"version":"CommandV1","origId":503877321549084,"guid":"1803ab95-8c32-479f-af7f-b3157ef932de","subtype":"command","commandType":"auto","position":5.0,"command":"// StringIndexer: Read input column \"label\" (digits) and annotate them as categorical values.\nval indexer = new StringIndexer().setInputCol(\"label\").setOutputCol(\"indexedLabel\")\n// DecisionTreeClassifier: Learn to predict column \"indexedLabel\" using the \"features\" column.\nval dtc = new DecisionTreeClassifier().setLabelCol(\"indexedLabel\")\n// Chain indexer + dtc together into a single ML Pipeline.\nval pipeline = new Pipeline().setStages(Array(indexer, dtc))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c93f6861-5f2d-4cc1-bc5f-38f70b894b78"},{"version":"CommandV1","origId":503877321549085,"guid":"88948d93-57b5-478f-8401-1b4f34ae5722","subtype":"command","commandType":"auto","position":6.0,"command":"val model = pipeline.fit(training)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"7bd8658e-c08c-4ac5-a8ac-c1598188212d"},{"version":"CommandV1","origId":503877321549086,"guid":"1ff93c16-1abf-4250-856b-f58c992cd4a3","subtype":"command","commandType":"auto","position":7.0,"command":"%md ## Exploring \"maxDepth\": training trees of different sizes\n\nJust to remind you what we saw before, we have the old code in the next cell, commented out. Then the Spark grid search version.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"66a169bf-b0c0-43fc-b444-e8e76794bd53"},{"version":"CommandV1","origId":503877321549087,"guid":"e03f9421-a166-4af1-85ec-7806ebf4e860","subtype":"command","commandType":"auto","position":8.0,"command":"// ORIGINAL:\n\n/*\nval variedMaxDepthModels = (0 until 8).map { maxDepth =>\n  // For this setting of maxDepth, learn a decision tree.\n  dtc.setMaxDepth(maxDepth)\n  // Create a Pipeline with our feature processing stage (indexer) plus the tree algorithm\n  val pipeline = new Pipeline().setStages(Array(indexer, dtc))\n  // Run the ML Pipeline to learn a tree.\n  pipeline.fit(training)\n}\n\nimport org.apache.spark.ml.evaluation.MulticlassClassificationEvaluator\nval evaluator = new MulticlassClassificationEvaluator().setLabelCol(\"indexedLabel\")\n\n// For each maxDepth setting, make predictions on the test data, and compute the accuracy metric.\nval accuracies = (0 until 8).map { maxDepth =>\n  val model = variedMaxDepthModels(maxDepth)\n  // Calling transform() on the test set runs the fitted pipeline.\n  // The learned model makes predictions on each test example.\n  val predictions = model.transform(test)\n  // Calling evaluate() on the predictions DataFrame computes our accuracy metric.\n  (maxDepth, evaluator.evaluate(predictions))\n}.toDF(\"maxDepth\", \"accuracy\")\n*/","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"407d5b57-313c-4e9b-9c2c-5bc7e6c55854"},{"version":"CommandV1","origId":503877321549088,"guid":"39416085-cb73-4ddb-8818-be5cb337dbd6","subtype":"command","commandType":"auto","position":9.0,"command":"// new version\n\nimport org.apache.spark.ml.tuning._\nimport org.apache.spark.ml.evaluation.MulticlassClassificationEvaluator\n\nval pipeline = new Pipeline().setStages(Array(indexer, dtc))\n\nval grid = new ParamGridBuilder()\n  .addGrid(dtc.maxDepth, (4 until 8).toArray) // run it a little faster on CE\n  .build()\n\nval evaluator = new MulticlassClassificationEvaluator()\n  .setLabelCol(\"indexedLabel\")\n  .setMetricName(\"accuracy\")\n\nval cv = new CrossValidator()\n  .setNumFolds(3) // run faster on CE\n  .setEstimator(pipeline)\n  .setEstimatorParamMaps(grid)\n  .setEvaluator(evaluator)\n\nval cvModel = cv.fit(training)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"1741f9b8-a483-4d4e-b9b7-f677180225aa"},{"version":"CommandV1","origId":503877321549089,"guid":"361dab1a-0b28-4b0e-92ad-3c2346b97bd4","subtype":"command","commandType":"auto","position":10.0,"command":"cvModel.getEstimatorParamMaps.zip(cvModel.avgMetrics)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8efe58e1-94b8-414f-ad84-c8fd89e83406"},{"version":"CommandV1","origId":503877321549090,"guid":"6887dc09-174b-4d50-a163-492a54152a58","subtype":"command","commandType":"auto","position":11.0,"command":"%md After identifying the best ParamMap, CrossValidator finally re-fits the Estimator using the best ParamMap and the entire dataset.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"19b34f7e-0bfb-40cd-ba35-95cf0433a6d5"},{"version":"CommandV1","origId":503877321549091,"guid":"545f167e-8cb9-4c20-9004-07baea0e0f49","subtype":"command","commandType":"auto","position":12.0,"command":"evaluator.evaluate(cvModel.transform(test))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"447446b2-2249-44f9-bd3c-7dda913f7acc"},{"version":"CommandV1","origId":503877321549092,"guid":"af1d1f46-3631-4b9e-908f-d2debf47c381","subtype":"command","commandType":"auto","position":13.0,"command":"%md Even though deeper trees are more powerful, they are not always better.  If we kept increasing the depth, training would take longer and longer.  We also might risk [overfitting](https://en.wikipedia.org/wiki/Overfitting) (fitting the training data so well that our predictions get worse on test data); it is important to tune parameters *based on [held-out data](https://en.wikipedia.org/wiki/Test_set)* to prevent overfitting.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"010dae9f-4740-4f4b-afcb-038516703f18"},{"version":"CommandV1","origId":503877321549093,"guid":"ec531bc4-27fc-437e-8dec-71631e8c12ab","subtype":"command","commandType":"auto","position":14.0,"command":"%md ## Your Turn: Exploring \"maxBins\": discretization for efficient distributed computing\n\n*From here on ... this is just the original code we saw earlier. Your goal is to rewrite it using Spark's grid search (similar to the example above)*\n\n__The one thing you won't (easily) be able to do is see and plot the performance at for the various hyperparameter settings. The main goal is just to get a tuned (cross-validated) model. You can look at the API docs and other notebook examples for obtaining the performance of the model for each parameter choice (it is available).__\n\n<hr/>\n\nThis section explores a more expert-level setting `maxBins`.  For efficient distributed training of Decision Trees, Spark and most other libraries discretize (or \"bin\") continuous features (such as pixel values) into a finite number of values.  This is an important step for the distributed implementation, but it introduces a tradeoff: Larger `maxBins` mean your data will be more accurately represented, but it will also mean more communication (and slower training).\n\nThe default value of `maxBins` generally works, but it is interesting to explore on our handwritten digit dataset.  Remember our digit image from above:\n\n![Image of a digit](http://training.databricks.com/databricks_guide/digit.png)\n\nIt is grayscale.  But if we set `maxBins = 2`, then we are effectively making it a black-and-white image, not grayscale.  Will that affect the accuracy of our model?  Let's see!","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f80c5e2d-8537-4325-a1ca-8dfce0783c74"},{"version":"CommandV1","origId":503877321549094,"guid":"27032334-a09b-4f05-b421-556e23055895","subtype":"command","commandType":"auto","position":15.0,"command":"/*\ndtc.setMaxDepth(6) // Set maxDepth to a reasonable value.\nval accuracies = Seq(2, 4, 8, 16, 32).map { case maxBins =>\n  // For this value of maxBins, learn a tree.\n  dtc.setMaxBins(maxBins)\n  val pipeline = new Pipeline().setStages(Array(indexer, dtc))\n  val model = pipeline.fit(training)\n  // Make predictions on test data, and compute accuracy.\n  val predictions = model.transform(test)\n  (maxBins, evaluator.evaluate(predictions))\n}.toDF(\"maxBins\", \"accuracy\")\ndisplay(accuracies)\n*/","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"2c2dca48-dbbf-4684-89ad-17785f0b6036"},{"version":"CommandV1","origId":503877321549095,"guid":"bf82424a-521a-40b7-ab90-7f36cbf8cba8","subtype":"command","commandType":"auto","position":16.0,"command":"","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5008d34f-c514-400c-b837-efb91a749687"}],"dashboards":[],"guid":"13821312-c2ff-48bc-9213-f539e7617e28","globalVars":{},"iPythonMetadata":null,"inputWidgets":{}}