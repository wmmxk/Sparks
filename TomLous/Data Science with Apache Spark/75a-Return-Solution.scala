{"version":"NotebookV1","origId":503877321548849,"name":"75a-Return-Solution","language":"scala","commands":[{"version":"CommandV1","origId":503877321548851,"guid":"b9c8db0f-c095-456c-a281-9dd2b3532dd9","subtype":"command","commandType":"auto","position":1.0,"command":"%md # Decision Trees - Tuning with Spark Grid Search\n\n__GOAL: Replace the \"manual\" tuning of the trees in this notebook with grid search, using ParamGridBuilder, CrossValidator, and Evaluator__\n\n__we'll do the first one together, and you can try your hand at the second tuning exersise in the notebook__","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"34f39beb-9760-4654-9e4d-ca71430afbe6"},{"version":"CommandV1","origId":503877321548852,"guid":"d7eab331-1600-43ea-b989-7935e3b2bd72","subtype":"command","commandType":"auto","position":2.0,"command":"%md We'll get set up as before:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"18f62583-5830-458d-bb65-1b021b3fcc16"},{"version":"CommandV1","origId":503877321548853,"guid":"10a217b8-2374-4401-82b5-2dd1ec3f9fb7","subtype":"command","commandType":"auto","position":3.0,"command":"val training = sqlContext.read.format(\"libsvm\").load(\"/databricks-datasets/mnist-digits/data-001/mnist-digits-train.txt\").cache\nval test = sqlContext.read.format(\"libsvm\").load(\"/databricks-datasets/mnist-digits/data-001/mnist-digits-test.txt\").cache","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b9dc9681-5757-4ab1-aeaa-78bfb22dfe76"},{"version":"CommandV1","origId":503877321548854,"guid":"1f162165-30c0-4478-aaee-08321025e2ce","subtype":"command","commandType":"auto","position":4.0,"command":"// Import the ML algorithms we will use.\nimport org.apache.spark.ml.classification.{DecisionTreeClassifier, DecisionTreeClassificationModel}\nimport org.apache.spark.ml.feature.StringIndexer\nimport org.apache.spark.ml.Pipeline","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f8445a96-8ca9-4704-91c3-acf235f9936e"},{"version":"CommandV1","origId":503877321548855,"guid":"9e6e6a91-f760-4a6e-94de-7e1b9ff5a6ba","subtype":"command","commandType":"auto","position":5.0,"command":"// StringIndexer: Read input column \"label\" (digits) and annotate them as categorical values.\nval indexer = new StringIndexer().setInputCol(\"label\").setOutputCol(\"indexedLabel\")\n// DecisionTreeClassifier: Learn to predict column \"indexedLabel\" using the \"features\" column.\nval dtc = new DecisionTreeClassifier().setLabelCol(\"indexedLabel\")\n// Chain indexer + dtc together into a single ML Pipeline.\nval pipeline = new Pipeline().setStages(Array(indexer, dtc))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"94abf6c9-ca91-4076-abc1-a7970e7f2e27"},{"version":"CommandV1","origId":503877321548856,"guid":"0a7ee128-7aab-460c-af90-bf14c41c8f0f","subtype":"command","commandType":"auto","position":6.0,"command":"val model = pipeline.fit(training)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"349046da-af39-4c89-8818-1fb735e12dd2"},{"version":"CommandV1","origId":503877321548857,"guid":"6d43f584-2771-4f37-89bc-8043196df51b","subtype":"command","commandType":"auto","position":7.0,"command":"%md ## Exploring \"maxDepth\": training trees of different sizes\n\nJust to remind you what we saw before, we have the old code in the next cell, commented out. Then the Spark grid search version.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"842b1f9e-42db-4b15-9b03-ba90837f1ef3"},{"version":"CommandV1","origId":503877321548858,"guid":"4b8203e8-eb03-42b8-86e8-4f9a5130f668","subtype":"command","commandType":"auto","position":8.0,"command":"// ORIGINAL:\n\n/*\nval variedMaxDepthModels = (0 until 8).map { maxDepth =>\n  // For this setting of maxDepth, learn a decision tree.\n  dtc.setMaxDepth(maxDepth)\n  // Create a Pipeline with our feature processing stage (indexer) plus the tree algorithm\n  val pipeline = new Pipeline().setStages(Array(indexer, dtc))\n  // Run the ML Pipeline to learn a tree.\n  pipeline.fit(training)\n}\n\nimport org.apache.spark.ml.evaluation.MulticlassClassificationEvaluator\nval evaluator = new MulticlassClassificationEvaluator().setLabelCol(\"indexedLabel\")\n\n// For each maxDepth setting, make predictions on the test data, and compute the accuracy metric.\nval accuracies = (0 until 8).map { maxDepth =>\n  val model = variedMaxDepthModels(maxDepth)\n  // Calling transform() on the test set runs the fitted pipeline.\n  // The learned model makes predictions on each test example.\n  val predictions = model.transform(test)\n  // Calling evaluate() on the predictions DataFrame computes our accuracy metric.\n  (maxDepth, evaluator.evaluate(predictions))\n}.toDF(\"maxDepth\", \"accuracy\")\n*/","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"2a9c9793-dafc-494f-8e8b-0b155cbb6d40"},{"version":"CommandV1","origId":503877321548859,"guid":"539de6de-35a5-4faf-b62f-27c19d891e9c","subtype":"command","commandType":"auto","position":9.0,"command":"// new version\n\nimport org.apache.spark.ml.tuning._\nimport org.apache.spark.ml.evaluation.MulticlassClassificationEvaluator\n\nval pipeline = new Pipeline().setStages(Array(indexer, dtc))\n\nval grid = new ParamGridBuilder()\n  .addGrid(dtc.maxDepth, (4 until 8).toArray) // run it a little faster on CE\n  .build()\n\nval evaluator = new MulticlassClassificationEvaluator()\n  .setLabelCol(\"indexedLabel\")\n  .setMetricName(\"accuracy\")\n\nval cv = new CrossValidator()\n  .setNumFolds(3) // run faster on CE\n  .setEstimator(pipeline)\n  .setEstimatorParamMaps(grid)\n  .setEvaluator(evaluator)\n\nval cvModel = cv.fit(training)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c4190d1a-fe13-41e0-90ad-d2845d858d64"},{"version":"CommandV1","origId":503877321548860,"guid":"f9f5cc94-5355-4605-a346-01493e2681b4","subtype":"command","commandType":"auto","position":10.0,"command":"cvModel.getEstimatorParamMaps.zip(cvModel.avgMetrics)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"204ba5c4-4d9f-4eba-9a78-07ab3351018d"},{"version":"CommandV1","origId":503877321548861,"guid":"5a0fe5db-bfbd-4398-9c9f-65cc5d92e9b1","subtype":"command","commandType":"auto","position":11.0,"command":"%md After identifying the best ParamMap, CrossValidator finally re-fits the Estimator using the best ParamMap and the entire dataset.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"2dd6d7ca-dbf9-42f8-8cb3-624a164bdceb"},{"version":"CommandV1","origId":503877321548862,"guid":"717cb9dc-0065-4efe-aae6-c57079dbca71","subtype":"command","commandType":"auto","position":12.0,"command":"evaluator.evaluate(cvModel.transform(test))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"883a5609-e146-4336-8d6c-ef607dd2a54d"},{"version":"CommandV1","origId":503877321548863,"guid":"aeda466c-db69-4e2a-a36a-5200527921b2","subtype":"command","commandType":"auto","position":13.0,"command":"%md Even though deeper trees are more powerful, they are not always better.  If we kept increasing the depth, training would take longer and longer.  We also might risk [overfitting](https://en.wikipedia.org/wiki/Overfitting) (fitting the training data so well that our predictions get worse on test data); it is important to tune parameters *based on [held-out data](https://en.wikipedia.org/wiki/Test_set)* to prevent overfitting.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8e018719-1607-44ad-a7c4-9ac94a32380d"},{"version":"CommandV1","origId":503877321548864,"guid":"678673a5-8e4d-4588-be0e-ee37fa148f49","subtype":"command","commandType":"auto","position":14.0,"command":"%md ## Your Turn: Exploring \"maxBins\": discretization for efficient distributed computing\n\n*From here on ... this is just the original code we saw earlier. Your goal is to rewrite it using Spark's grid search (similar to the example above)*\n\n__The one thing you won't (easily) be able to do is see and plot the performance at for the various hyperparameter settings. The main goal is just to get a tuned (cross-validated) model. You can look at the API docs and other notebook examples for obtaining the performance of the model for each parameter choice (it is available).__\n\n<hr/>\n\nThis section explores a more expert-level setting `maxBins`.  For efficient distributed training of Decision Trees, Spark and most other libraries discretize (or \"bin\") continuous features (such as pixel values) into a finite number of values.  This is an important step for the distributed implementation, but it introduces a tradeoff: Larger `maxBins` mean your data will be more accurately represented, but it will also mean more communication (and slower training).\n\nThe default value of `maxBins` generally works, but it is interesting to explore on our handwritten digit dataset.  Remember our digit image from above:\n\n![Image of a digit](http://training.databricks.com/databricks_guide/digit.png)\n\nIt is grayscale.  But if we set `maxBins = 2`, then we are effectively making it a black-and-white image, not grayscale.  Will that affect the accuracy of our model?  Let's see!","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"90bd5c28-5cb6-4b04-8d82-265bd6f0ccd9"},{"version":"CommandV1","origId":503877321548865,"guid":"f825239d-a8b1-4103-a374-d3c52cb29261","subtype":"command","commandType":"auto","position":15.0,"command":"/*\ndtc.setMaxDepth(6) // Set maxDepth to a reasonable value.\nval accuracies = Seq(2, 4, 8, 16, 32).map { case maxBins =>\n  // For this value of maxBins, learn a tree.\n  dtc.setMaxBins(maxBins)\n  val pipeline = new Pipeline().setStages(Array(indexer, dtc))\n  val model = pipeline.fit(training)\n  // Make predictions on test data, and compute accuracy.\n  val predictions = model.transform(test)\n  (maxBins, evaluator.evaluate(predictions))\n}.toDF(\"maxBins\", \"accuracy\")\ndisplay(accuracies)\n*/","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"6de99901-4684-45fc-a0b4-37d81074c50f"},{"version":"CommandV1","origId":503877321548866,"guid":"1106e575-7854-4038-a58d-2d9529d3838f","subtype":"command","commandType":"auto","position":16.0,"command":"import org.apache.spark.ml.tuning._\nimport org.apache.spark.ml.evaluation.MulticlassClassificationEvaluator\n\ndtc.setMaxDepth(6)\n\nval pipeline = new Pipeline().setStages(Array(indexer, dtc))\n\nval grid = new ParamGridBuilder()\n  .addGrid(dtc.maxBins, Seq(2, 4, 8, 16, 32).toArray) // run it a little faster on CE\n  .build()\n\nval evaluator = new MulticlassClassificationEvaluator()\n  .setLabelCol(\"indexedLabel\")\n  .setMetricName(\"accuracy\")\n\nval cv = new CrossValidator()\n  .setNumFolds(3) // run faster on CE\n  .setEstimator(pipeline)\n  .setEstimatorParamMaps(grid)\n  .setEvaluator(evaluator)\n\nval cvModel = cv.fit(training)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"e6f1de0e-5906-41eb-8550-e951d901de4f"},{"version":"CommandV1","origId":503877321548867,"guid":"38408068-eb41-4405-aaf4-7d88c42e8201","subtype":"command","commandType":"auto","position":17.0,"command":"cvModel.getEstimatorParamMaps.zip(cvModel.avgMetrics)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"d1137bf2-eec7-4362-a086-3afa0212d3ed"},{"version":"CommandV1","origId":503877321548868,"guid":"09faa0c3-4596-4e0b-a4c3-1d29e09e7987","subtype":"command","commandType":"auto","position":18.0,"command":"evaluator.evaluate(cvModel.transform(test))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8f933516-8c8d-4c3f-8fd4-57115a7e7412"},{"version":"CommandV1","origId":503877321548869,"guid":"28d04989-fc1d-481a-852b-608bbc1dd19c","subtype":"command","commandType":"auto","position":19.0,"command":"","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"d49c0dd5-c2e1-47d2-8c72-481a91774dc1"}],"dashboards":[],"guid":"fbae3ab6-390b-4be3-86b9-0ae2f587fc9d","globalVars":{},"iPythonMetadata":null,"inputWidgets":{}}