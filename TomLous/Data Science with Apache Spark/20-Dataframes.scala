{"version":"NotebookV1","origId":503877321548888,"name":"20-Dataframes","language":"scala","commands":[{"version":"CommandV1","origId":503877321548890,"guid":"ea7c8f9d-9569-4f73-9d6c-00ac66d39b4c","subtype":"command","commandType":"auto","position":1.0,"command":"%md #SparkSQL and DataFrames\n\n* Some form of SQL processing has been part of the core distribution since 1.0 (April 2014)\n  * The purpose is to runs SQL / HiveQL queries, optionally alongside or replacing existing Hive deployments\n\n* __Modern SparkSQL and DataFrames represent the same thing: a new language-independent, high-performance query engine implementation__\n  * SparkSQL/DataFrames is different from, and replaces, a variety of older approaches including Shark, Hive-on-Spark, and SchemaRDD\n  * Although Spark contains its own data processing engine, it can integrate closely with a Hive metastore\n\n<img src=\"http://i.imgur.com/kOZqeNo.png\" width=\"600\">","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"90bcebd3-a33e-4895-af02-e47d6765c0e9"},{"version":"CommandV1","origId":503877321548891,"guid":"be8d7ac0-7a61-4c6e-b71a-c45eefab4082","subtype":"command","commandType":"auto","position":2.0,"command":"%md ##SparkSQL, DataFrames and DataSets Represent the Same Component in Modern Spark\n\n##### This component allows major optimizations by Spark, far beyond what is possible with the RDD API, in terms of both execution speed and data storage size.\n\n* DataFrame/DataSet API and SQL (typically via the HiveQL parser) are equivalent ways to do the same tasks.\n  * SQL serves many general purposes, including analytic work via BI tools (over JDBC and the Thriftserver)\n  * DataFrames offer more programmatic control and an API familiar to users of Pandas or R\n  * DataSets are a generalization of DataFrames and the underlying engine, to support more data types and stronger type enforcement","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"6f9c9d0f-6d10-41de-b6c3-e2edbca2dc26"},{"version":"CommandV1","origId":503877321548892,"guid":"04eb186c-79a9-406a-a914-3a0ea09b7d14","subtype":"command","commandType":"auto","position":3.0,"command":"%md ##DataFrame API\n\n* Enable wider audiences beyond ?Big Data? engineers to leverage the power of distributed processing\n  * Seamless integration with all big data tooling and infrastructure via Spark\n  * Designed from the ground-up to support modern big data and data science applications\n\n* Inspired by data frames in R and Python (Pandas), but offering transparent scale-out support\n  * ... from kilobytes of data on a single laptop to petabytes on a large cluster\n\n* Support for a wide array of data formats and storage systems\n* State-of-the-art optimization and code generation through the Spark SQL Catalyst optimizer\n* APIs for Python, Java, Scala, and R\n\nSee\n* https://spark.apache.org/docs/latest/sql-programming-guide.html \n* http://databricks.com/blog/2015/02/17/introducing-dataframes-in-spark-for-large-scale-data-science.html","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5664e89c-701e-47b0-9845-b8d68330e91d"},{"version":"CommandV1","origId":503877321548893,"guid":"40e2d4e4-d11b-4785-9a8b-299489496471","subtype":"command","commandType":"auto","position":4.0,"command":"%md ##DataFrames\nThe preferred abstraction in Spark (introduced in 1.3)\n* Strongly typed collection of distributed elements\n  * Built on Resilient Distributed Datasets\n* _Immutable once constructed_\n* Track lineage information to efficiently recompute lost data\n* Enable operations on collection of elements in parallel\n\nYou construct DataFrames\n* by parallelizing existing collections (e.g., Pandas DataFrames) \n* by transforming an existing DataFrame\n* from files in HDFS, Hive tables, or any other storage system (e.g., Parquet in S3)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ebdd35db-68a5-4950-93e4-642c983343e4"},{"version":"CommandV1","origId":503877321548894,"guid":"92142db9-d0aa-4435-9527-bd5a061eba08","subtype":"command","commandType":"auto","position":5.0,"command":"%md ##Why Use DataFrames instead of RDDs?\n\n\n* For new users familiar with data frames in other programming languages, this API should make them feel at home\n* For existing Spark users, the API will make Spark easier to program than using RDDs\n* For both sets of users, DataFrames will improve performance through intelligent optimizations and code-generation\n<br/>\n<br/>\n<br/>\n<img src=\"http://i.imgur.com/0uLWgHl.png\" width=\"600\">","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"450154fc-047c-4db9-8606-9c15ac07c0c5"},{"version":"CommandV1","origId":503877321548895,"guid":"4b5a96b9-9163-40c1-8752-523f494ee5a1","subtype":"command","commandType":"auto","position":6.0,"command":"%md ##DataFrames can be significantly faster than RDDs. \n\nAnd they perform the same, regardless of language.\n\n<img src=\"http://i.imgur.com/CQCBB2E.png\" width=\"600\">","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"6a1ab694-5996-4c93-9c26-5c661bef9f9f"},{"version":"CommandV1","origId":503877321548896,"guid":"3296d62d-e7d1-43ff-b38a-9f17e2509a7b","subtype":"command","commandType":"auto","position":7.0,"command":"%md ## Write Less Code: Input & Output\n\nUnified interface to reading/writing data in a variety of formats.\n\n```\nval df = sqlContext.\n  read.\n  format(\"json\").\n  option(\"samplingRatio\", \"0.1\").\n  load(\"/Users/spark/data/stuff.json\")\n\ndf.write.\n   format(\"parquet\").\n   mode(\"append\").\n   partitionBy(\"year\").\n   saveAsTable(\"faster-stuff\")\n```","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"a52a7839-c33d-4254-a8ab-7dbc9fa1fc65"},{"version":"CommandV1","origId":503877321548897,"guid":"bab45c19-796a-4e22-8a06-9389c7dadb86","subtype":"command","commandType":"auto","position":8.0,"command":"%md ##Data Sources supported by DataFrames\n\n<img src=\"http://i.imgur.com/sdYuTIv.png\" width=\"600\">","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"7e4baf37-58e5-4ebd-8a74-de4ef2e92bf8"},{"version":"CommandV1","origId":503877321548898,"guid":"f778d820-376c-4e91-a123-a318d7525b86","subtype":"command","commandType":"auto","position":9.0,"command":"%md ##Write Less Code: High-Level Operations\n\nSolve common problems concisely with DataFrame functions:\n* selecting columns and filtering\n* joining different data sources\n* aggregation (count, sum, average, etc.)\n* plotting results (e.g., with Pandas)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"7e4a267e-474d-408f-a817-95b74aabbf7c"},{"version":"CommandV1","origId":503877321548899,"guid":"fe13daaa-fe19-4126-b574-736fd60b1a64","subtype":"command","commandType":"auto","position":10.0,"command":"%md ##Write Less Code: Compute an Average\n\n<img src=\"http://i.imgur.com/gLDgzDP.png\" width=\"600\">\n\n__The Spark code is much shorter ... but it's not clear. It's complex, and the programmer's intent is not communicated clearly.__\n\nLet's look at making that both *shorter* __and__ *easier*. First, we'll set up some data to use:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"7707a0c5-7ab9-44ff-bfa7-f9bf534be25f"},{"version":"CommandV1","origId":503877321548900,"guid":"660c0a81-27b0-4e75-8ba1-c527bfb6cc48","subtype":"command","commandType":"auto","position":11.0,"command":"// set up RDD\nval data = sc.parallelize(List((\"Jim\", 30), (\"Anne\", 31), (\"Jim\", 32)))\n\n// set up DataFrame\nimport org.apache.spark.sql.functions._\ndata.toDF(\"name\", \"age\").registerTempTable(\"people\")","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"a7b6eb53-bcab-418a-9fa8-7eb67b39c0ad"},{"version":"CommandV1","origId":503877321548901,"guid":"c2b69ad5-3f8a-4e73-a586-312576859599","subtype":"command","commandType":"auto","position":12.0,"command":"%md Run the RDD-based Spark code to calculate average ages for each name:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c9f5224b-3611-4159-9a4f-c0501f36bced"},{"version":"CommandV1","origId":503877321548902,"guid":"36cadf3d-4853-4c28-b84f-a8558768c810","subtype":"command","commandType":"auto","position":13.0,"command":"data.map { x => (x._1, (x._2, 1)) }\n  .reduceByKey { case (x,y) => \n      (x._1 + y._1, x._2 + y._2) }\n  .map { x => (x._1, x._2._1 / x._2._2) }\n  .collect()","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"78ff46ee-3685-41bb-b310-993ddf1ad792"},{"version":"CommandV1","origId":503877321548903,"guid":"745d2ef4-2b3c-426a-ac1a-3317546b38c7","subtype":"command","commandType":"auto","position":14.0,"command":"%md Now the same calculation, using the DataFrame API.\n\nYou'll probably agree that the following is much easier to understand and harder to mess up when coding:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"4b4977a3-b3f0-4bc4-a968-3f25a824cf97"},{"version":"CommandV1","origId":503877321548904,"guid":"d91aa749-9d03-4c6d-adff-7418fba1fe7d","subtype":"command","commandType":"auto","position":15.0,"command":"sqlContext.table(\"people\")\n          .groupBy(\"name\")\n          .agg(avg(\"age\"))\n          .collect()","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"26514ded-c10f-41cb-a5eb-92a6d8ead499"},{"version":"CommandV1","origId":503877321548905,"guid":"a7d31377-6516-4b33-92db-71fa5e6862de","subtype":"command","commandType":"auto","position":16.0,"command":"%md ###... and Spark can optimize it!\n\nThe full API Docs are here:\n\n* Scala - http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.package\n* Java - http://spark.apache.org/docs/latest/api/java/index.html?org/apache/spark/sql/package-summary.html\n* Python - http://spark.apache.org/docs/latest/api/python/pyspark.sql.html#module-pyspark.sql\n* R - http://spark.apache.org/docs/latest/api/R/index.html\n\n__BUT for a shortcut to finding APIs you need, learning, or trying to solve a problem, bookmark (or at least look first at) the following items:__\n\nIn org.apache.spark.sql:\n1. DataFrame class\n2. Column class\n3. functions object\n4. GroupedData class","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"421c0b3e-7268-40b9-b044-2a61cb813952"},{"version":"CommandV1","origId":503877321548906,"guid":"4cc3f857-5855-489f-9379-00256f745467","subtype":"command","commandType":"auto","position":17.0,"command":"%md ##Create a DataFrame\n\nDataFrames need a schema: consistent columns, each with a name and a type.\n\nWe can create one from a Parquet file easily, because all of that schema info is built into the Parquet file:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ff4224de-53df-4d69-ae5a-6877a550274a"},{"version":"CommandV1","origId":503877321548907,"guid":"d4fb64eb-6d4b-4a03-afcd-75014ddb4bc1","subtype":"command","commandType":"auto","position":18.0,"command":"val people = sqlContext.read.parquet(\"dbfs:/mnt/training/ssn/names.parquet\")","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c1d6d3f1-47da-4831-abe0-053951471773"},{"version":"CommandV1","origId":503877321548908,"guid":"138eaca9-7d04-429c-8cc9-8998b01fb63c","subtype":"command","commandType":"auto","position":19.0,"command":"%md ## Use DataFrames","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"0365c81a-9b14-4dde-97c7-ff4bef58a545"},{"version":"CommandV1","origId":503877321548909,"guid":"65c670d3-99a6-4ee0-b373-adcb9df17857","subtype":"command","commandType":"auto","position":20.0,"command":"people.show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f40b7cd2-13c6-41f6-bfbc-4b6be30bd0d8"},{"version":"CommandV1","origId":503877321548910,"guid":"a0821a50-5b55-4667-a3c5-0f3a0236abe4","subtype":"command","commandType":"auto","position":21.0,"command":"var popular = people.filter($\"total\" > 80000)\npopular.show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"6efefefa-efd6-42c2-b624-a3659f3ca684"},{"version":"CommandV1","origId":503877321548911,"guid":"ff7095ec-b30f-4dbb-8564-91e83e34c779","subtype":"command","commandType":"auto","position":22.0,"command":"people.select($\"firstName\", $\"total\" * 1000)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"4c338efb-d0a4-4dbc-83b0-e98bf8815aa5"},{"version":"CommandV1","origId":503877321548912,"guid":"4eadbaa0-36fd-4c28-a059-7fb2d1cd4d0e","subtype":"command","commandType":"auto","position":23.0,"command":"%md Many DataFrame API functions have overloads that can take Column objects or SQL string column names (select) or even expressions (filter):","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"42c8af05-3b02-421a-a421-172d9f9cdc07"},{"version":"CommandV1","origId":503877321548913,"guid":"769c5593-5108-4c72-904c-bf16f2379f69","subtype":"command","commandType":"auto","position":24.0,"command":"println(people.filter(\"total < 80000\"))\nprintln(people.select(\"firstName\", \"total\"))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"e3589523-a122-4ae6-840c-1b4e10aba2d4"},{"version":"CommandV1","origId":503877321548914,"guid":"56b3c928-ee29-4641-9451-ff2211745c03","subtype":"command","commandType":"auto","position":25.0,"command":"%md We'll learn more about columns and expressions in a bit. For now, here are a couple more examples of logic (grouping/counting, joining) using the DataFrame API:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"97fda681-b02f-4970-bde6-3a476819f699"},{"version":"CommandV1","origId":503877321548915,"guid":"755f43b5-9a75-4911-950a-c72018f05870","subtype":"command","commandType":"auto","position":26.0,"command":"people.groupBy(\"year\").count","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c1706cd5-793f-4950-9626-940bee5bb341"},{"version":"CommandV1","origId":503877321548916,"guid":"fa72eb2d-bea9-48cc-b5bd-9bee305d91be","subtype":"command","commandType":"auto","position":27.0,"command":"val scores = sc.parallelize(List( (\"James\", 100), (\"Linda\", 100) )).toDF(\"name\", \"score\")\n\npeople.join(scores, people(\"firstName\") === scores(\"name\"), \"inner\")","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"63822abb-b272-48de-aa73-93157e397dbf"},{"version":"CommandV1","origId":503877321548917,"guid":"de5f39ab-3e8c-4035-9770-4813208b7cf0","subtype":"command","commandType":"auto","position":28.0,"command":"%md ## Connecting DataFrames and SparkSQL","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"1ea114ec-b8bc-43d0-9479-eb6cce6f9f0e"},{"version":"CommandV1","origId":503877321548918,"guid":"046681b6-b21f-43f1-a7cd-e28ae9ade3c7","subtype":"command","commandType":"auto","position":29.0,"command":"people.registerTempTable(\"people\")\nsqlContext.sql(\"SELECT count(*) FROM people\")","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"a61fa821-0d90-4c66-9860-0d82540e22a6"},{"version":"CommandV1","origId":503877321548919,"guid":"ee78db25-00a8-42b2-818b-eab1b5613be1","subtype":"command","commandType":"auto","position":30.0,"command":"%md Note that registerTempTable just creates a symbol representing the query (a bit like a SQL View) so that, later, we can use SQL to reference that query. We can treat it like a table, and the parser will understand what we mean. These symbols (\"tables\") are available to any code using the sqlContext -- they can also access this table directly if they like (without SQL) by calling ```sqlContext.table(\"people\")```","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"98c788c6-3d29-4cca-b8ae-6759347b65a7"},{"version":"CommandV1","origId":503877321548920,"guid":"0ac6ea46-64c2-4274-972b-007ec8d5cd40","subtype":"command","commandType":"auto","position":31.0,"command":"%md ## DataFrames and SparkSQL\n\nThe DataFrames API provides a programmatic interface?really, a domain-specific language (DSL)?for interacting with your data.\n* Spark SQL allows you to manipulate distributed data with SQL queries. Currently, two SQL dialects are supported.\n  * If you?re using a Spark SQLContext, the only supported dialect is ?sql,? a rich subset of SQL 92.\n  * If you?re using a HiveContext, the default dialect is \"hiveql\", corresponding to Hive's SQL dialect. ?sql? is also available, but ?hiveql? is a richer dialect.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"e691c767-0c59-4dee-92e7-40c092d3c091"},{"version":"CommandV1","origId":503877321548921,"guid":"4cbcfd5f-8813-42ce-8df9-a2e67ab41550","subtype":"command","commandType":"auto","position":32.0,"command":"%md ##SparkSQL\n\nYou issue SQL queries through a SQLContext or HiveContext, using the sql() method.\n* The sql() method returns a DataFrame.\n* You can mix DataFrame methods and SQL queries in the same code.\n* To use SQL, you must either:\n  * query a persisted Hive table, or\n  * make a table alias for a DataFrame, using registerTempTable()","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f29474f0-7f56-4e09-856e-d8a87fafe8b0"},{"version":"CommandV1","origId":503877321548922,"guid":"89021298-0a86-4232-8792-d02d809101ff","subtype":"command","commandType":"auto","position":33.0,"command":"%md ##Transformations, Actions, Laziness\n\nDataFrames are lazy. Transformations contribute to the query plan, but they don't execute anything. \nActions cause the execution of the query.\n\n|Transformations|Actions|\n|---|---|\n|filter,select,drop,intersect,join|count,collect,show,head,take\n\n\n*Actions cause the execution of the query.*\n\n__What, exactly, does ?execution of the query? mean? It means:__\n* Spark initiates a distributed read of the data source\n* The data flows through the transformations (the RDDs resulting from the Catalyst query plan)\n* The result of the action is pulled back into the driver JVM.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f0e97280-80f3-44e1-9c8d-928e8b9610f2"},{"version":"CommandV1","origId":503877321548923,"guid":"17a2c207-7808-4525-b88f-ead0a943e18d","subtype":"command","commandType":"auto","position":34.0,"command":"people.take(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"724628bf-98c5-4deb-a765-b484e57d9b7a"},{"version":"CommandV1","origId":503877321548924,"guid":"dcd3fc1f-348b-4cdf-9b87-ea72e3e72e5c","subtype":"command","commandType":"auto","position":35.0,"command":"%md ##DataFrames have Schemas\n\nIn the previous example, we created DataFrames from Parquet and JSON data.\n* A Parquet table has a schema (column names and types) that Spark can use. Parquet also allows Spark to be efficient about how it pares down data.\n* Spark can infer a Schema from a JSON file.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"6fb0af17-fe7d-452b-8b10-e662dc19fe7d"},{"version":"CommandV1","origId":503877321548925,"guid":"e3b9ec79-5ec3-4df1-9794-b11d86c15ba3","subtype":"command","commandType":"auto","position":36.0,"command":"%md ##Columns\n\nWhen we say ?column? here, what do we mean?\n\n* a DataFrame column is an abstraction. It provides a common column-oriented view of the underlying data, regardless of how the data is really organized.\n\n* Columns are important because much of the DataFrame API consists of functions that take or return columns (even if they don?t look that way at first).","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"e177f25b-9c5f-4c71-bf5d-6d74e6fb5bb8"},{"version":"CommandV1","origId":503877321548926,"guid":"f00853bd-3162-498c-b6ce-20f591893df4","subtype":"command","commandType":"auto","position":37.0,"command":"%md ## How Do Columns Map to Common Data Types?\n\n<img src=\"http://i.imgur.com/QfUf7Ub.png\" width=\"500\">","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"59b9c8cf-2219-485f-a330-dc2a899160dc"},{"version":"CommandV1","origId":503877321548927,"guid":"89d93309-b2e2-42e4-adae-93e5613c1e33","subtype":"command","commandType":"auto","position":38.0,"command":"%md #### SQL, CSV, JSON ...\n\n<img src=\"http://i.imgur.com/ajxRmWN.png\" width=\"720\">","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f10bacbb-87d4-4c62-a624-4c96fe03b538"},{"version":"CommandV1","origId":503877321548928,"guid":"81822bbe-f406-45b7-b5ba-683073dc1f6e","subtype":"command","commandType":"auto","position":39.0,"command":"%md ##Accessing Colums\n\nAssume we have a DataFrame, df, that reads a data source that has \"first\", \"last\", and \"age\" columns.\n\n|Python|Scala|Java|R|\n|---|---|---|---|\n|df[\"first\"], df.first?|df(\"first\"), $\"first\"?|df.col(\"first\")|df$first|\n\n\n? In Python, it?s possible to access a DataFrame?s columns either by attribute (df.age) or by indexing (df['age']). While the former is convenient for interactive data exploration, you should use the index form. It's future proof and won?t break with column names that are also attributes on the DataFrame class.\n\n?The $ syntax can be ambiguous if there are multiple DataFrames in the lineage.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"a22adb10-b947-43d3-aa81-18ad9992e279"},{"version":"CommandV1","origId":503877321548929,"guid":"59a1f2c2-f157-42f1-a719-6b13c261a8bc","subtype":"command","commandType":"auto","position":40.0,"command":"%md ## printSchema()\n\nYou can have Spark tell you what it thinks the data schema is, by calling the printSchema() method.  (This is mostly useful in the shell.)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"9c8a2de7-6e38-4e96-92df-93d6a79f628d"},{"version":"CommandV1","origId":503877321548930,"guid":"df7a4dbc-c9ae-4084-b10b-360eb7e29448","subtype":"command","commandType":"auto","position":41.0,"command":"people.printSchema","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"59fc6ef2-df6e-47ce-bb9e-02db13f040ac"},{"version":"CommandV1","origId":503877321548931,"guid":"46a935de-5e50-4d51-bf00-3e6549de667c","subtype":"command","commandType":"auto","position":42.0,"command":"%md ##Schema Inference\n\n* Some data sources (e.g., parquet) can expose a formal schema; others (e.g., plain text files) don?t. How do we fix that?\n* You can create an RDD of a particular type and let Spark infer the schema from that type. We?ll see how to do that in a moment.\n* You can use the API to specify the schema programmatically.\n\nThe key thing to remember is that a schema has consistent columns, column types, and column names. We can \"mix-and-match\" where these come from, as long as all three are there. For example, a CSV file might provide consistent columns and types, and we might fill in the column names; alternatively, a file might have column data and fields names, but we need to supply the types.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"a2c04b34-797d-438d-93ef-28345fae8eef"},{"version":"CommandV1","origId":503877321548932,"guid":"29af76ce-5bbb-4512-8bb6-7a4cce1a0184","subtype":"command","commandType":"auto","position":43.0,"command":"%md ##Schema Application Example\n\nSuppose you have a file that looks like this:\n\n```\nErin,Shannon,F,42\nNorman,Lockwood,M,81\nMiguel,Ruiz,M,64\nRosalita,Ramirez,F,14\nAlly,Garcia,F,39\nClaire,McBride,F,23\nAbigail,Cottrell,F,75\nJosé,Rivera,M,59\nRavi,Dasgupta,M,25\n...\n```\n\nThe file has no schema, but it?s obvious there is one:\n\n|Field|Type|\n|---|---|\n|First name|string|\n|Last name|string|\n|Gender|string|\n|Age|integer|\n\nLet's see how to get Spark to infer that schema.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"008959a1-db89-4654-b43d-7dbf2e9f0672"},{"version":"CommandV1","origId":503877321548933,"guid":"4988bfc2-9343-4cef-b699-fb8dd607de9e","subtype":"command","commandType":"auto","position":44.0,"command":"case class Person(firstName: String,\n                  lastName:  String,\n                  gender:    String,\n                  age:       Int)\n\nval rdd = sc.textFile(\"people.csv\")\n\nval peopleRDD = rdd.map { line =>\n  val cols = line.split(\",\")\n  Person(cols(0), cols(1), cols(2), cols(3).toInt)\n}\n\nval df = peopleRDD.toDF\n\n// df: DataFrame = [firstName: string, lastName: string, gender: string, age: int]","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"9b709180-d60e-481e-861a-057888de659c"},{"version":"CommandV1","origId":503877321548934,"guid":"a744c53e-0737-4526-b145-a8d27d348f37","subtype":"command","commandType":"auto","position":45.0,"command":"%md ##Schema Inference\n\nWe can also force schema inference\n* ... without creating our own People type, \n* by using a fixed-length data structure (such as a tuple) \n* and supplying the column names to the toDF() method.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"d772fff3-9477-43ff-95f5-121fcd735936"},{"version":"CommandV1","origId":503877321548935,"guid":"9aa7d889-bb09-4cda-9c0c-260cf22bd82b","subtype":"command","commandType":"auto","position":46.0,"command":"%md ##Why do you have to use a tuple?\n* In Python, you don?t. You can use any iterable data structure (e.g., a list).\n* In Scala, you do. Tuples have fixed lengths and fixed types for each element at compile time. For instance:\n\n  __```Tuple4[String,String,String,Int]```__\n\n* The DataFrames API uses this information to infer the number of columns and their types. It cannot do that with an array.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"dfe9a26d-7981-451e-b20f-e86dd4e22adf"},{"version":"CommandV1","origId":503877321548936,"guid":"2c577eaf-78d2-4723-9966-32b2028dc898","subtype":"command","commandType":"auto","position":47.0,"command":"val rdd = sc.textFile(\"people.csv\")\n\nval peopleRDD = rdd.map { line =>\n  val cols = line.split(\",\")\n  (cols(0), cols(1), cols(2), cols(3).toInt)\n}\n\nval df = peopleRDD.toDF(\"firstName\", \"lastName\", \"gender\", \"age\")","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c18be2e2-22a8-488f-8c04-912769ef364c"},{"version":"CommandV1","origId":503877321548937,"guid":"f9bec493-a62f-4e76-aac5-f690c077ae1e","subtype":"command","commandType":"auto","position":48.0,"command":"%md ##One last method for schemas\n\nInternally, a Dataframe schema is represented by the public StructType type: http://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.types.StructType\n\nYou can use this type to create a schema as in the following example.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"88459433-b56b-4c5c-9cec-579d96919192"},{"version":"CommandV1","origId":503877321548938,"guid":"7be1ec6b-606d-43ca-ad13-6d09663b6170","subtype":"command","commandType":"auto","position":49.0,"command":"import org.apache.spark.sql.types._\n\nval schema = StructType(Seq( StructField(\"name\", StringType, false), StructField(\"age\", IntegerType, false) ))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"06d85171-e562-483c-95f1-e752ba02306f"},{"version":"CommandV1","origId":503877321548939,"guid":"9feee555-203f-4f3c-ad5c-b26f8a14488f","subtype":"command","commandType":"auto","position":50.0,"command":"%md __But__ ... when and where would that be useful?\n\nMainly when loading files with lots of fields ... case classes and tuples are limited to 22 elements, and lots of real-world tables are hundreds of columns wide.\n\nIn addition, it's easy to build StructType schemas programmatically from a source of schema information -- for example, lots of legacy systems contain files that describe column names and types, so we can create a Spark Dataframe schema by reading that file and building a StructType to apply to corresponding raw data files.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ebbecbd6-ce10-49f3-bfc9-e6de8260cd6b"},{"version":"CommandV1","origId":503877321548940,"guid":"b71b6589-b5b3-4aaf-a2c3-ca2fbbb31da6","subtype":"command","commandType":"auto","position":51.0,"command":"%md ##show()\n\nYou can look at the first n elements in a DataFrame with the show() method. If not specified, n defaults to 20.\n\nThis method is an action. It:\n* reads (or re-reads) the input source\n* executes the RDD DAG across the cluster\n* pulls the n elements back to the driver JVM\n* displays those elements in a tabular form","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f7e50b5c-a84e-48c8-bd9a-277fd71da140"},{"version":"CommandV1","origId":503877321548941,"guid":"3627b036-9932-48d4-ba79-21b613bb0697","subtype":"command","commandType":"auto","position":52.0,"command":"people.show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"67aa99b5-6274-4d78-bdd3-d6b945551559"},{"version":"CommandV1","origId":503877321548942,"guid":"f22b7c90-92f7-4c4a-bda2-f91cc857e155","subtype":"command","commandType":"auto","position":53.0,"command":"%md ##select()\n\nselect() is like a SQL SELECT, allowing you to limit the results to specific columns.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"14e9bfef-4a19-4bb4-964b-6c4e12c52a30"},{"version":"CommandV1","origId":503877321548943,"guid":"22c1b1f0-8974-40f9-80f8-22fba687e575","subtype":"command","commandType":"auto","position":54.0,"command":"people.select($\"firstName\", $\"year\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"87fd4f21-db67-4ed0-8dff-917922ad8541"},{"version":"CommandV1","origId":503877321548944,"guid":"a9b4e65b-db7a-41ee-a1d9-17e9cf879ae5","subtype":"command","commandType":"auto","position":55.0,"command":"%md\nselect() also lets you create on-the-fly *derived* columns (similar to SQL select)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"72ad74fa-45c5-45b9-a469-3e684d7dbdeb"},{"version":"CommandV1","origId":503877321548945,"guid":"01236fca-4bfd-4112-90f0-699d4c8a4e3a","subtype":"command","commandType":"auto","position":56.0,"command":"people.select($\"firstName\", $\"year\", $\"year\" > 1950, $\"year\" + 1000).show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"2401cff7-bfb9-40ea-8919-810bfb912570"},{"version":"CommandV1","origId":503877321548946,"guid":"9112b459-ff19-4a58-af96-e23f3629bb59","subtype":"command","commandType":"auto","position":57.0,"command":"%md Note that the expressions like ```$\"year\" + 1000``` are also Columns (and that's what you'll see in the DataFrame.select method signature).\n\nThe operators here (> or +) are just methods of Column, and they also return a Column:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5f953766-88e1-4283-9ef4-fce570748c88"},{"version":"CommandV1","origId":503877321548947,"guid":"d901bffe-cc0d-4d66-8774-70cecb29eec9","subtype":"command","commandType":"auto","position":58.0,"command":"people(\"year\") + 10","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"a8767709-213b-4fb9-bdf2-72b8dd07b3f6"},{"version":"CommandV1","origId":503877321548948,"guid":"a89a8813-e6aa-476f-8a81-470afb2f3f35","subtype":"command","commandType":"auto","position":59.0,"command":"(people(\"year\") + 10) == (people(\"year\").+(10))","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"18cb9d99-f3d8-4108-bea2-fc9c220f280d"},{"version":"CommandV1","origId":503877321548949,"guid":"8f39920f-3d6f-461c-972c-0569063c31d9","subtype":"command","commandType":"auto","position":60.0,"command":"people.apply(\"year\").+(10)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f3d91683-dc6f-43a8-9cef-aaa5de8193c1"},{"version":"CommandV1","origId":503877321548950,"guid":"f807caf3-7cae-4797-ab39-1a2f3498fe5c","subtype":"command","commandType":"auto","position":61.0,"command":"%md ... and of course you can use SQL:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ae8e8348-0b4d-45a4-a075-e2c2fea7413b"},{"version":"CommandV1","origId":503877321548951,"guid":"a2c8cd97-cc8d-419b-b3c1-986f196f0553","subtype":"command","commandType":"auto","position":62.0,"command":"people.registerTempTable(\"people\")\nsqlContext.sql(\"SELECT firstName, year, year + 1000 as future FROM people\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"57b5e115-faea-4289-a2e8-c8749eac9d07"},{"version":"CommandV1","origId":503877321548952,"guid":"3376cbb0-013d-4e4a-be0d-af70b0f2721b","subtype":"command","commandType":"auto","position":63.0,"command":"%md ##filter()\n\nThe filter() method allows you to filter rows out of your results.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b191c5fb-503d-40c9-9400-ff5f7d8f9b69"},{"version":"CommandV1","origId":503877321548953,"guid":"025ee76d-ae86-4d36-87f5-df1e2e3c21fd","subtype":"command","commandType":"auto","position":64.0,"command":"people.filter($\"year\" > 1990).select($\"firstName\", $\"year\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"fa257b53-345c-407b-8096-1527289b69e8"},{"version":"CommandV1","origId":503877321548954,"guid":"6b9de862-9769-4fc6-85b1-8e830bdc708c","subtype":"command","commandType":"auto","position":65.0,"command":"%md Here's how filter appears (as a WHERE clause) in SQL:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5a9f97ab-cc74-4eed-850b-5f7a2f56ac04"},{"version":"CommandV1","origId":503877321548955,"guid":"20300d2e-df1e-4652-8b75-ea00a90d9faa","subtype":"command","commandType":"auto","position":66.0,"command":"sqlContext.sql(\"SELECT firstName, year FROM people WHERE year > 1990\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"562d05aa-3bd5-493e-9dc8-04ddf7e29fc9"},{"version":"CommandV1","origId":503877321548956,"guid":"1f6b76e6-17c8-457b-b872-f5d8cb0adedc","subtype":"command","commandType":"auto","position":67.0,"command":"%md ##orderBy()\n\nThe orderBy() method allows you to sort the results.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"31a6af42-0324-4b2c-b2c9-ac3a32ac12d7"},{"version":"CommandV1","origId":503877321548957,"guid":"b360b8d1-96dd-4843-96ff-661a5055c529","subtype":"command","commandType":"auto","position":68.0,"command":"people.filter(people(\"year\") > 1990).select(people(\"firstName\"), people(\"year\")).orderBy(people(\"year\"), people(\"firstName\")).show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"a997ede5-6e71-4a11-98a4-94d0450c587b"},{"version":"CommandV1","origId":503877321548958,"guid":"dd8dbcfb-22a6-424f-a27d-a1e8d0fef0aa","subtype":"command","commandType":"auto","position":69.0,"command":"%md It?s easy to reverse the sort order: look for the __desc__ method calls in the following example.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c9c6b5df-5203-4b94-8ebe-bca3026eb339"},{"version":"CommandV1","origId":503877321548959,"guid":"a6178940-9c78-4da2-a46b-a766018010df","subtype":"command","commandType":"auto","position":70.0,"command":"people.filter(people(\"year\") > 1990).select(people(\"firstName\"), people(\"year\")).orderBy(people(\"year\") desc, people(\"firstName\") desc).show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"00cdccc1-020d-438b-a4d9-e2fe69ee81c2"},{"version":"CommandV1","origId":503877321548960,"guid":"823bb653-7e52-4e68-a247-518b8e8b72b4","subtype":"command","commandType":"auto","position":71.0,"command":"%md In SQL, it's pretty normal looking:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f5d423d5-d4a2-4119-a863-3ff39fa6e173"},{"version":"CommandV1","origId":503877321548961,"guid":"26b74e3c-b492-43e3-8c4e-994bdf3eac69","subtype":"command","commandType":"auto","position":72.0,"command":"sqlContext.sql(\"SELECT firstName, year FROM people ORDER BY year DESC, firstName DESC\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"d87b79a6-3151-4e3e-a96f-d2a611c040bc"},{"version":"CommandV1","origId":503877321548962,"guid":"11624c02-5341-4b1f-8460-536c0d1faa0d","subtype":"command","commandType":"auto","position":73.0,"command":"%md ##as() or alias()\n\nas() or alias() allows you to rename a column\n\n* it?s especially useful with generated columnns (which are sometimes assigned names with non-alphanumeric characters)\n* and joins (to disambiguate columns with same name in each of the joined tables)\n\nnote: in Python you must use \"alias\" because \"as\" is a reserved word","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"6a0fb0cc-4a4b-434c-9ef2-78f180e5ce37"},{"version":"CommandV1","origId":503877321548963,"guid":"71b43f4a-6b10-4943-8df9-0b79d5dbf95d","subtype":"command","commandType":"auto","position":74.0,"command":"people.select($\"firstName\", $\"year\", ($\"year\" > 2000).as(\"recent\")).show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8553bac4-7b3e-4914-8b4b-e136ead6c9e1"},{"version":"CommandV1","origId":503877321548964,"guid":"5c1ba756-864c-49ce-9cae-8f84b1842b2c","subtype":"command","commandType":"auto","position":75.0,"command":"sqlContext.sql(\"SELECT firstName, year, year > 2000 AS recent FROM people\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"3167bb21-0e09-4736-b55d-728670c03e2a"},{"version":"CommandV1","origId":503877321548965,"guid":"24a2c155-d3de-47b9-8b34-aa620a948839","subtype":"command","commandType":"auto","position":76.0,"command":"%md ##groupBy()\n\ngroupBy() is used to group data (rows) by their value(s) (in one or more specified columns) for aggregations, such as count() or sum()","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"16d69489-e884-4980-aa40-59abb413a5ac"},{"version":"CommandV1","origId":503877321548966,"guid":"96eb6980-b5b0-4faf-9eec-4da6b9d02292","subtype":"command","commandType":"auto","position":77.0,"command":"people.groupBy($\"year\").count.show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"315c9b0c-1430-47d0-ae4a-d3ca97a67c9c"},{"version":"CommandV1","origId":503877321548967,"guid":"b09eb00a-d9ca-4414-9217-f8e5a154f495","subtype":"command","commandType":"auto","position":78.0,"command":"import org.apache.spark.sql.functions._\npeople.groupBy($\"year\").agg(sum($\"total\")).show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c20b4eae-41ff-4e74-98fa-9115109a5719"},{"version":"CommandV1","origId":503877321548968,"guid":"a46d17cd-fa57-4c11-b674-11ff8830384a","subtype":"command","commandType":"auto","position":79.0,"command":"sqlContext.sql(\"SELECT year, count(*) AS count, SUM(total) AS total FROM people GROUP BY year\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"352d89e9-5d85-4fd9-ad80-be874b49e305"},{"version":"CommandV1","origId":503877321548969,"guid":"11ef5e9d-654f-4d52-bf68-38a9a9b5def4","subtype":"command","commandType":"auto","position":80.0,"command":"%md ##Joins\n\nLet's assume we had a file that looked like this:\n\n```\nDacia:Rosella:Samborski:F:1940-08-06:274357:932-39-7400\nLoria:Suzie:Cassino:F:1964-01-31:166618:940-40-2137\nLashaunda:Markita:Rockhill:F:1936-06-02:185766:923-83-5563\nCandace:Marcy:Goike:F:1971-09-25:92497:935-40-2967\nMarhta:Filomena:Bonin:F:1926-06-29:40013:968-22-1158\nRachel:Gwyn:Mcmonigle:F:1951-04-27:211468:926-47-4803\nLorine:Valencia:Bilous:F:2012-09-08:26612:992-10-1262\nAlene:Berniece:Somji:F:1926-04-25:74027:989-16-1381\nSadye:Mara:Morrisseau:F:1930-07-01:209278:971-50-8157\nShawn:Reginia:Battisti:F:1962-08-26:190167:993-42-5846\n```\n\nSuppose we want to join this list against our list of names ... perhaps we'd like to estimate how unusual each first name is.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"90b7d610-3464-4072-8c27-4b6da165d17c"},{"version":"CommandV1","origId":503877321548970,"guid":"e1b27ea6-e7d8-4b58-bb11-540dc2058410","subtype":"command","commandType":"auto","position":81.0,"command":"val sampleData = sqlContext.read.format(\"com.databricks.spark.csv\")\n  .option(\"delimiter\", \":\")\n  .load(\"dbfs:/mnt/training/dataframes/people.txt\").select($\"_c0\" as \"name\", $\"_c4\" as \"birthdate\")\n\nsampleData.show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"abc42005-1cdf-4d2f-a4b1-3fb43ff064a3"},{"version":"CommandV1","origId":503877321548971,"guid":"754a6d44-dedf-41b9-9a6c-eebb6f17d436","subtype":"command","commandType":"auto","position":82.0,"command":"%md We can join people to sampleData on the name field with syntax like this:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"3d3241d2-1adb-4581-bbe5-9967c770a40a"},{"version":"CommandV1","origId":503877321548972,"guid":"31f809a0-76c1-4bc4-8077-6f62bf5e54b0","subtype":"command","commandType":"auto","position":83.0,"command":"people.join(sampleData, people(\"firstName\") === sampleData(\"name\")).show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"0174cd4c-fcd2-44b5-8f96-3e2f4fcea346"},{"version":"CommandV1","origId":503877321548973,"guid":"adce4f30-6cb3-4144-935c-573b28b4795c","subtype":"command","commandType":"auto","position":84.0,"command":"%md We might be able to add some business value if we can join on the year as well as the name. We can use some built-in DataFrame column functions to extract the year from the (string) birthdate column, and try the join again:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b367c4fe-d3c0-4568-bfa0-d924c856d799"},{"version":"CommandV1","origId":503877321548974,"guid":"8a70c372-1252-4ff1-bd00-ecc99d044aea","subtype":"command","commandType":"auto","position":85.0,"command":"// aside from the DataFrame and Column classes,\n// this is where most of the helper functions live:\nimport org.apache.spark.sql.functions._ \n// split(col, pattern) is located here\n\n// lets us use strongly-typed value IntegerType below:\nimport org.apache.spark.sql.types._ \n\n// cast is a method of the Column class, and withColumn is a method of the DataFrame class:\nval sampleDataWithYear = sampleData.withColumn(\"birthyear\", split($\"birthdate\", \"-\")(0) cast IntegerType)\n\nsampleDataWithYear.show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"47368b57-acba-40cd-814d-83614acc155a"},{"version":"CommandV1","origId":503877321548975,"guid":"33bc328b-ce7b-455f-b8cb-ff0634c3a2cf","subtype":"command","commandType":"auto","position":86.0,"command":"val joined = people.join(sampleDataWithYear, people(\"firstName\") === sampleDataWithYear(\"name\") && people(\"year\") === sampleDataWithYear(\"birthyear\"))\n\njoined.select(\"firstName\", \"total\", \"year\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"793ccbfd-b5bb-46df-8005-119ab390d10c"},{"version":"CommandV1","origId":503877321548976,"guid":"df4ece86-82ab-4350-a81a-57ff0c40aa7e","subtype":"command","commandType":"auto","position":87.0,"command":"%md ##What Other Handy Functions Can I Use?\n\nIn addition to the members of DataFrame and Column, there are over 100 helpful functions that operate on columns, defined in ```org.apache.spark.sql.functions```\n\nThese include:\n* Date/Time : Convert timestamps, extract fields, arithmetic on dates, parse arbitrary date strings\n* Math : Factorial, log, radians, base change...\n* Conditional : Greatest, least, isnull...\n* String: Base64, regex, length, trim, split, levenshtein...\n\nHere is an example for a common task: converting Unix timestamps into date formatted string, and then into SQL datetime types:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"c88981a1-4a44-4602-9f5d-0055344c2611"},{"version":"CommandV1","origId":503877321548977,"guid":"7b40a817-696c-4903-881f-b719ac1f70ed","subtype":"command","commandType":"auto","position":88.0,"command":"val data = Array((2,1420001316L), (4,1440000006L), (6,1410001316L)) \nval df = sc.parallelize(data).toDF(\"id\", \"timestamp\")\n\nval withStringDate = df.withColumn(\"string_date\", from_unixtime(df(\"timestamp\")))\nval withRealDate = withStringDate.withColumn(\"real_date\", to_utc_timestamp(withStringDate(\"string_date\"), \"GMT\"))\nwithRealDate.show","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"d691a868-0dc4-4e72-8602-12bae1058059"},{"version":"CommandV1","origId":503877321548978,"guid":"fd6b2935-e59a-42f6-bf1d-d047282afe8e","subtype":"command","commandType":"auto","position":89.0,"command":"%md Note the schema information about the columns in the above output.\n\nBut what if there is just no way to solve our problem with all of these APIs?","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"4df74116-e7eb-492f-9ef0-b22d28f46c43"},{"version":"CommandV1","origId":503877321548979,"guid":"ce15904b-39bf-4bdf-bc59-720e555c71d1","subtype":"command","commandType":"auto","position":90.0,"command":"%md ##User-Defined Functions\n\nAbove, we extracted the year from the birthdate string by string-splitting and casting using built-in functions.\n\nIf we had an actual date or datetime column, we could also use the built-in year() function to solve the problem.\n\nBut suppose we didn't have either of those options, and we needed to do some custom processing on each row, to produce a new column value.\n\nIn this example, we'd like to apply a function like the following:\n\n```\ndef extractYear(birthdate:String) = birthdate.split(\"-\")(0).toInt\nextractYear(\"2009-10-31\")\n\nres42: Int = 2009\n```\n\nWe can create a function like that, and convert it to a Spark UDF that operates on (and returns a column):","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"02b5b20a-7f14-45de-b04b-d234c02c4859"},{"version":"CommandV1","origId":503877321548980,"guid":"c0c4f559-2bab-48a3-aa6a-1979923af81a","subtype":"command","commandType":"auto","position":91.0,"command":"val extractYear = sqlContext.udf.register(\"pullOutYear\", (birthdate:String) => birthdate.split(\"-\")(0).toInt)\n\nsampleData.select($\"name\", $\"birthdate\", extractYear($\"birthdate\") as \"birthyear\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8c322b79-8ca6-445c-8da5-cead0c636409"},{"version":"CommandV1","origId":503877321548981,"guid":"928156b6-4d1b-4bd4-a883-0f3d0074279d","subtype":"command","commandType":"auto","position":92.0,"command":"%md What's that ```pullOutYear``` string doing in there? That name is available to SQL commands:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b9055deb-30e0-47ee-925f-80dbf9919ded"},{"version":"CommandV1","origId":503877321548982,"guid":"03344234-b916-4a75-8f75-e7df00e26643","subtype":"command","commandType":"auto","position":93.0,"command":"sampleData.registerTempTable(\"sampleData\")\nsqlContext.sql(\"SELECT name, birthdate, pullOutYear(birthdate) AS birthyear FROM sampleData\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"3b22189c-d697-4478-9b7e-6799fb7434bc"},{"version":"CommandV1","origId":503877321548983,"guid":"36756459-4d09-410a-bb25-442b1d48cc71","subtype":"command","commandType":"auto","position":94.0,"command":"%md __It is strongly preferable to use a combination of built-in functions, rather than defining your own.__\n\nWhy? Besides being (usually) easier, Spark *cannot optimizie your UDF functions*\n\nIn fact, Spark cannot \"see inside\" your UDF functions at all. This means, for example, that a join on a UDF will require a Cartesian join, then testing every pair of values against your UDF. \n\nIn addition, most built-in functions include support for code generation, which offers significant speed improvements.\n\nBut if a UDF is the only reasonable solution, it is easy to add one.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"46a95575-77bd-484a-b440-694fdf497475"},{"version":"CommandV1","origId":503877321548984,"guid":"034fdcd4-9220-4889-ae27-0572bea35e5d","subtype":"command","commandType":"auto","position":95.0,"command":"%md ##SparkSQL: Just a Little More Info\n\nAs we've seen, Spark SQL operations generally return DataFrames. So, in addition to starting with a DataFrame, calling registerTempTable, and then executing SQL, like we did above ... we can also go the other direction, starting with SQL and switching to DataFrames whenever we'd like:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"508c88d2-5303-4ccd-b83c-5ab4ecb957a6"},{"version":"CommandV1","origId":503877321548985,"guid":"75057e8c-4831-4818-9ca9-c06a9d111aa7","subtype":"command","commandType":"auto","position":96.0,"command":"%sql CREATE TEMPORARY TABLE more_people \nUSING parquet \nOPTIONS (path \"dbfs:/mnt/training/ssn/names.parquet\")","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8a30d1c8-5354-4509-b883-81b29efcc826"},{"version":"CommandV1","origId":503877321548986,"guid":"878730d5-74fb-4193-891c-ff7b55477b59","subtype":"command","commandType":"auto","position":97.0,"command":"sqlContext.table(\"more_people\").filter($\"year\" > 2010).show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"85d2e86a-9a5f-43e8-b9e9-e988ed561d33"},{"version":"CommandV1","origId":503877321548987,"guid":"444282a5-2760-4d8a-bf1c-7866daab937b","subtype":"command","commandType":"auto","position":98.0,"command":"%md Because these operations return DataFrames, all the usual DataFrame operations are available.\n\n. . . including the ability to create new temporary tables:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"1d8c47f7-88f5-4102-9ba8-9af40b2de0b5"},{"version":"CommandV1","origId":503877321548988,"guid":"636d1188-467f-4b88-8e64-b4e9ef8c4bae","subtype":"command","commandType":"auto","position":99.0,"command":"sqlContext.sql(\"SELECT * FROM more_people WHERE year = 2014\").registerTempTable(\"names2014\")\n\nsqlContext.table(\"names2014\").show(5)","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ffd4cbf6-e972-4078-ba7e-a9888111f00b"},{"version":"CommandV1","origId":503877321548989,"guid":"99ccee14-36c8-4349-82ec-313b70e71e18","subtype":"command","commandType":"auto","position":100.0,"command":"%md ##Window Functions\n\nAllow us to query over ranges or ?windows? within data set\n* Supported in many SQL database environments\n* Any aggregate function can be used, in addition to window-specific ranking and analytic functions\n* Spark Window Functions work with SQL or DSL\n* In DSL, create a WindowSpec using Window helper object, then use windowfunction?s column .over(windowspec)\n\nHere's a typical task: calculate rankings within multiple groups -- in this example, simultaneously query rankings of sports teams in their respective divisions:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8181f41c-c45f-4a40-a568-e35ebf27dd85"},{"version":"CommandV1","origId":503877321548990,"guid":"33ba3c5d-f37f-4757-b832-1a3f4bb0ddbe","subtype":"command","commandType":"auto","position":101.0,"command":"val data = Array((\"Bears\", \"E\", 10), (\"Lizards\", \"W\", 8), (\"Giraffes\", \"W\", 7), (\"Tigers\", \"E\", 9), (\"Crickets\", \"E\", 6), (\"Bats\", \"W\", 6)) \nval df = sc.parallelize(data).toDF(\"team\", \"division\", \"wins\")\ndf.registerTempTable(\"scores\") //for SQL\n\nval rankings = sqlContext.sql(\"SELECT team, division, wins, rank() OVER (PARTITION BY division ORDER BY wins desc) as rank FROM scores\")\nrankings.show","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b8a05b35-c316-4de6-a843-7e453b01ff7b"},{"version":"CommandV1","origId":503877321548991,"guid":"3e8dd481-e5ab-4528-8f91-b55f35b3b80d","subtype":"command","commandType":"auto","position":102.0,"command":"%md In the DataFrame API, we need to create a \"WindowSpec\" object first, then call ```rank().over(windowSpec)```:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"fa735774-307a-4e35-81b7-b428837a2d1f"},{"version":"CommandV1","origId":503877321548992,"guid":"6f30893d-da94-4cf1-82f1-7b8bad32618c","subtype":"command","commandType":"auto","position":103.0,"command":"import org.apache.spark.sql.expressions._\nimport org.apache.spark.sql.functions._\n\nval ws = Window.partitionBy(df(\"division\")).orderBy(-df(\"wins\"))\ndf.withColumn(\"rank\", rank().over(ws)).show","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5a534af8-aa54-447d-b14c-8f0cdcc8a6b6"},{"version":"CommandV1","origId":503877321548993,"guid":"5c1431ae-6624-446b-aea0-3478db071d6e","subtype":"command","commandType":"auto","position":104.0,"command":"%md ##Supported Window Functions\n\n| |SQL|DataFrame API|\n|-|---|-------------|\n|Ranking functions|rank|rank|\n||dense\\_rank|denseRank|\n||percent\\_rank|percentRank|\n||ntile|ntile|\n||row\\_number|rowNumber|\n|Analytic functions|cume\\_dist|cumeDist|\n||first\\_value|firstValue|\n||last\\_value|lastValue|\n||lag|lag|\n||lead|lead|\n\nhttps://databricks.com/blog/2015/07/15/introducing-window-functions-in-spark-sql.html","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"e11cff17-e615-4086-a9ea-7458546cd8bd"},{"version":"CommandV1","origId":503877321548994,"guid":"6a037bb5-d014-4f04-8674-392682c4ada1","subtype":"command","commandType":"auto","position":105.0,"command":"%md ##User-Defined Aggregation Functions (UDAF)\n\nUser-defind functions as discussed earlier apply to one or more columns, but only in one row (record) at a time. So they are, effectively, map functions.\n\n####What about reduce-style custom functions, that can operate on more than one records at a time?\n\nIf we want to reduce, or aggregate, data from multiple rows in a DataFrame, and we cannot solve the problem with the built-in aggregations, Spark allows us to create User-Defined Aggregation Functions, or UDAFs\n\nSince this sort of functions needs to encapsulate a parallelizable reduce, it's a bit more complex. We need to implement a class that extends ```org.apache.spark.sql.UserDefinedAggregateFunction``` and implements 8 abstract methods.\n\nOnce we have a class that meets the requirements and implements our logic, we can instantiate it and use the instance just as we would one of the built-in aggregations like \"sum\" or \"count\" -- e.g., we can groupBy one or more columns, then aggregate over another.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f92008c2-38a1-4ff8-9501-8e016ce34e16"},{"version":"CommandV1","origId":503877321548995,"guid":"05f5ee53-9235-495e-aa34-372ade70f514","subtype":"command","commandType":"auto","position":106.0,"command":"%md In the example below, we will create a UDAF that collects all of the values of a particular column in all of the rows in a group. That is, we can groupBy one column and then \"collect\" all of the different values that appear (within the group) in a second column, and place those in an Array. This example will treat those values as Strings, its value will be Array[String]\n\nDescribed as code, we'd like to start with data like\n\n```val a = sc.parallelize(List((\"foo\", \"abc\"), (\"bar\", \"abc\"), (\"foo\", \"def\"))).toDF(\"name\", \"bonus\")```\n\nand then, if we group by the name column, we'll get a row for name \"foo\" where the aggregated column has a string array of \"abc\" and \"def\"\n\nSimilarly, we could group by the \"bonus\" column, and then we'll get a row for the bonus value \"abc\" where the aggregated column has a string array of the name values \"foo\" and \"bar\":","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"8bee355a-bebb-4c53-a10a-fb38ba39a0a7"},{"version":"CommandV1","origId":503877321548996,"guid":"5eba8658-a6a4-48d0-b2fd-2643fed4e8aa","subtype":"command","commandType":"auto","position":107.0,"command":"import org.apache.spark.sql.expressions.MutableAggregationBuffer\nimport org.apache.spark.sql.expressions.UserDefinedAggregateFunction\nimport org.apache.spark.sql.Row\nimport org.apache.spark.sql.types._\n \nclass Collect extends UserDefinedAggregateFunction {\n  def inputSchema: org.apache.spark.sql.types.StructType =\n    StructType(StructField(\"name\", StringType) :: Nil)\n \n  def bufferSchema: StructType = StructType(\n    StructField(\"strings\", ArrayType(StringType, false)) :: Nil\n  )\n \n  def dataType: DataType = ArrayType(StringType)\n  def deterministic: Boolean = true\n  def initialize(buffer: MutableAggregationBuffer): Unit = {\n    buffer(0) = Array[String]()\n  }\n \n  def update(buffer: MutableAggregationBuffer,input: Row): Unit = {\n    buffer(0) = buffer.getSeq(0) :+ input.getAs[String](0)\n  }\n \n  def merge(buffer1: MutableAggregationBuffer, buffer2: Row): Unit = {\n   buffer1(0) = buffer1.getSeq(0) ++ buffer2.getSeq(0)\n  }\n \n  def evaluate(buffer: Row): Any = {\n    buffer.getAs[Array[String]](0)\n  }\n}\n\nval collect = new Collect","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"d51ff7a2-fe30-456b-a225-a4f5ffaa59fe"},{"version":"CommandV1","origId":503877321548997,"guid":"ce64cde3-1b3d-44f3-b8df-5110e4287084","subtype":"command","commandType":"auto","position":108.0,"command":"%md Now we can use the instance \"collect\" as a UDAF and aggregate with it:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"e04a37c4-d39d-49a0-a0dd-3dd1ab93403e"},{"version":"CommandV1","origId":503877321548998,"guid":"49a3b06b-7a9b-4486-b42a-4d932ee3e8c0","subtype":"command","commandType":"auto","position":109.0,"command":"val a = sc.parallelize(List((\"foo\", \"abc\"), (\"bar\", \"abc\"), (\"foo\", \"def\"))).toDF(\"name\", \"bonus\")\na.groupBy($\"bonus\").agg(collect($\"name\")).show\na.groupBy($\"name\").agg(collect($\"bonus\")).show","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"b2787ddc-b5e9-41d9-a3cf-ff133b024f47"},{"version":"CommandV1","origId":503877321548999,"guid":"1f60161e-1c85-4498-b922-a6eb747c6e4a","subtype":"command","commandType":"auto","position":110.0,"command":"a.groupBy($\"name\").agg(collect($\"bonus\")).printSchema","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"04de144e-2901-4632-bcf0-7c9093d0d500"},{"version":"CommandV1","origId":503877321549000,"guid":"c0de8dea-f3cd-43a8-ae57-6f9d6260f629","subtype":"command","commandType":"auto","position":111.0,"command":"%md ##Complex Column Types\n\nDataframes can support complex types in a column. For example, a column's type can be a hashmap. It is common to encounter map-typped columns in an existing Hive environment, although Spark's support *does not require Hive*\n\nThere are several ways to access data in a map-typped column, depending upon whether we want to retrieve the map itself, or instead transform the Dataframe to bring map keys, values, or both up to top-level fields in the schema.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f5c28fa7-fc88-465d-a55d-257631329880"},{"version":"CommandV1","origId":503877321549001,"guid":"f5466e38-18a3-47c3-9376-ae72df4b1195","subtype":"command","commandType":"auto","position":112.0,"command":"val df = sc.parallelize(List( (\"John\", Map(\"games\"->12, \"highscore\" ->199) ), (\"Anne\", Map(\"games\"->9, \"highscore\" ->200 )  ))).toDF(\"name\", \"player_info\")\ndf.printSchema\ndf.show","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"454d541b-5990-4a87-8184-1561c644b52a"},{"version":"CommandV1","origId":503877321549002,"guid":"fe605556-cb8f-481b-8a02-7ea62cd2acc3","subtype":"command","commandType":"auto","position":113.0,"command":"%md The following code shows how the map is accessessed within a Row. Although \"collect\" will rarely be appropriate in big data settings, the focus here is on Row -- a Dataframe is a Dataset[Row] and can be transparently converted to a RDD[Row] if necessary.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"57b99c55-0567-4996-8214-2f877cfe1752"},{"version":"CommandV1","origId":503877321549003,"guid":"f54b8906-b43b-4c23-a6ec-d1e6886beef9","subtype":"command","commandType":"auto","position":114.0,"command":"val rows = df.filter($\"name\" === \"John\").select($\"player_info\").collect\nval map = rows(0).getMap[String,Int](0)\nmap(\"games\")","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"555173c2-8f96-4d43-827e-eaa4710358b2"},{"version":"CommandV1","origId":503877321549004,"guid":"7497b991-797c-45d7-a5b0-307524670230","subtype":"command","commandType":"auto","position":115.0,"command":"%md If we know the specific key we need from a map, we can project it into a top-level column using a \".\" syntax within a column name:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"38d1216a-dbc7-415e-8cd8-923ab0cc42fa"},{"version":"CommandV1","origId":503877321549005,"guid":"b00694b3-0a0e-449b-ace9-646ece659cb7","subtype":"command","commandType":"auto","position":116.0,"command":"df.select($\"name\", $\"player_info.highscore\").show","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f3af4ba1-96ec-4240-83d4-ba25611757dd"},{"version":"CommandV1","origId":503877321549006,"guid":"1ae3edc6-a469-4998-910e-689c0ecfec4c","subtype":"command","commandType":"auto","position":117.0,"command":"%md We can use the `explode` method to create a custom translation of a Map (or other structure) into one or more columns and/or rows. This is similar to a HiveQL `LATERAL VIEW`\n\nFirst, let's look at making one fixed column with custom String contents for the map: we can make 1 or more Rows from the map.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"13d458d8-b731-41fe-81d3-d1899e516004"},{"version":"CommandV1","origId":503877321549007,"guid":"e9bda7d5-4dac-4b43-bbde-39935ed816b3","subtype":"command","commandType":"auto","position":118.0,"command":"df.select($\"name\", $\"player_info\").explode(\"player_info\", \"entry\") {\n  player_info_map : Map[String,Int] => {\n    player_info_map.keys.map(k => k + \" : \" + player_info_map(k))\n  }\n}.show","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"6a2ba528-9a6b-465f-89c5-26c9e452ecfd"},{"version":"CommandV1","origId":503877321549008,"guid":"9a24f172-197e-4ce2-85ce-5ec793dd273f","subtype":"command","commandType":"auto","position":119.0,"command":"%md Sometimes, we'd like to make a number of new columns, perhaps representing specific keys that were in the map. We can do that too:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"ca7c274d-c16b-454a-b3ca-807ae9ea92f6"},{"version":"CommandV1","origId":503877321549009,"guid":"e5884ae4-57bb-43a0-ab2d-178fd33b8b3e","subtype":"command","commandType":"auto","position":120.0,"command":"case class PlayerInfo(games:Int, highscore:Int)\n\ndf.select($\"name\", $\"player_info\").explode($\"player_info\"){\n  r: Row => {\n    val map = r.getMap[String,Int](0)    \n    Seq(PlayerInfo(map(\"games\"), map(\"highscore\")))\n  }\n}.show","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"2a67bc43-c185-4357-8852-bbea1053972c"},{"version":"CommandV1","origId":503877321549010,"guid":"631668da-aeaf-42c6-b467-1b1930356c7b","subtype":"command","commandType":"auto","position":121.0,"command":"%md What if we want to expand each key-value pair in into its own row, a bit like a triple-store (https://en.wikipedia.org/wiki/Triplestore) ?\n\nWe can do that with the same `explode` call, by returning an iterator with different semantics:","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"9f319d0b-24a7-4d2b-bb54-37574f085061"},{"version":"CommandV1","origId":503877321549011,"guid":"3ffd7feb-a71e-44b0-a157-559c3b3dd3fb","subtype":"command","commandType":"auto","position":122.0,"command":"df.select($\"name\", $\"player_info\").explode($\"player_info\"){\n  r: Row => {\n    val map = r.getMap[String,Int](0)\n    map.keys.map(k => (k, map(k)))\n  }\n}.withColumnRenamed(\"_1\", \"map_key\").withColumnRenamed(\"_2\", \"map_value\").show","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"bb98927a-80af-4221-86c3-4a8069334cd2"},{"version":"CommandV1","origId":503877321549012,"guid":"05404eb2-7f59-4860-9b71-c32aac1d2d50","subtype":"command","commandType":"auto","position":123.0,"command":"%md ##DataFrame Limitations\n\n* Spark does not automatically repartition DataFrames optimally during shuffles\n  * During a DF shuffle, SparkSQL will just use ```spark.sql.shuffle.partitions``` to determined the number of partitions in the downstream RDD\n  * All SQL configurations can be changed, including this one\n    * via ```sqlContext.setConf(key, value)```\n    * or in Databricks: ```%sql SET key=val```","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"5b369d5c-4589-449f-9060-de32b20451e6"},{"version":"CommandV1","origId":503877321549013,"guid":"6fc28868-fbd0-4afb-985f-c4ee43641b9b","subtype":"command","commandType":"auto","position":124.0,"command":"%md ##Machine Learning Integration\n\n* Spark 1.2 introduced a new package called __spark.ml__, which aims to provide a uniform set of high-level APIs that help users create and tune practical machine learning pipelines.\n\n* Spark ML standardizes APIs for machine learning algorithms to make it easier to combine multiple algorithms into a single *pipeline*, or *workflow*.\n\n* Spark ML uses DataFrames as a dataset which can hold a variety of data types. \n  * For instance, a dataset could have different columns storing text, feature vectors, true labels, and predictions.","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0.0,"submitTime":0.0,"finishTime":0.0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"nuid":"f7de9950-825e-4328-954a-8e0bd7b2ffbe"}],"dashboards":[],"guid":"288eaaf9-2575-414f-a528-222803214ff2","globalVars":{},"iPythonMetadata":null,"inputWidgets":{}}